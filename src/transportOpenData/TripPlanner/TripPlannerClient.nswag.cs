//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

#pragma warning disable 108 // Disable "CS0108 '{derivedDto}.ToJson()' hides inherited member '{dtoBase}.ToJson()'. Use the new keyword if hiding was intended."
#pragma warning disable 114 // Disable "CS0114 '{derivedDto}.RaisePropertyChanged(String)' hides inherited member 'dtoBase.RaisePropertyChanged(String)'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword."
#pragma warning disable 472 // Disable "CS0472 The result of the expression is always 'false' since a value of type 'Int32' is never equal to 'null' of type 'Int32?'
#pragma warning disable 612 // Disable "CS0612 '...' is obsolete"
#pragma warning disable 649 // Disable "CS0649 Field is never assigned to, and will always have its default value null"
#pragma warning disable 1573 // Disable "CS1573 Parameter '...' has no matching param tag in the XML comment for ...
#pragma warning disable 1591 // Disable "CS1591 Missing XML comment for publicly visible type or member ..."
#pragma warning disable 8073 // Disable "CS8073 The result of the expression is always 'false' since a value of type 'T' is never equal to 'null' of type 'T?'"
#pragma warning disable 3016 // Disable "CS3016 Arrays as attribute arguments is not CLS-compliant"
#pragma warning disable 8600 // Disable "CS8600 Converting null literal or possible null value to non-nullable type"
#pragma warning disable 8602 // Disable "CS8602 Dereference of a possibly null reference"
#pragma warning disable 8603 // Disable "CS8603 Possible null reference return"
#pragma warning disable 8604 // Disable "CS8604 Possible null reference argument for parameter"
#pragma warning disable 8625 // Disable "CS8625 Cannot convert null literal to non-nullable reference type"
#pragma warning disable 8765 // Disable "CS8765 Nullability of type of parameter doesn't match overridden member (possibly because of nullability attributes)."

namespace TransportOpenData.TripPlanner
{
    using System = global::System;

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AddinfoClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public AddinfoClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.transport.nsw.gov.au/v1/tp";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Provides capability to display all public transport service status and incident information (as published from the Service Alert Messaging System).
        /// </summary>
        /// <remarks>
        /// This endpoint returns a list of service alerts or additional information about travelling on the public transport
        /// <br/>network. This list can be filtered by date, route type, route, operator or stop.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="filterDateValid">This parameter allows you to filter the returned items that are only valid on the specified date. The format of
        /// <br/>this field is `DD-MM-YYYY`. For example, 12 September 2016 would be represented by `12-09-2016`.</param>
        /// <param name="filterMOTType">This parameter allows you to filter the returned items by the modes of transport they affected. Available modes include:
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>
        /// <br/>To search for more than one mode, include the parameter multiple times.</param>
        /// <param name="filterPublicationStatus">This field can be used so only current alerts are returned, and not historic alerts.</param>
        /// <param name="itdLPxx_selStop">This parameter allows you to filter the returned items by its stop ID or global stop ID. For example, to retrieve items that are only
        /// <br/>relevant to Central Station, you would set this value to `10111010` (stop ID) or `200060` (global stop ID). You can use the `stop_finder` API call
        /// <br/>to determine the ID for a particular stop.</param>
        /// <param name="itdLPxx_selLine">This parameter allows you to filter the returned items by line number. For example, `020T1`. You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="itdLPxx_selOperator">This parameter allows you to filter the returned items by operator ID. You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="filterPNLineDir">This parameter allows you to filter the returned items by specific routes. The route is provided in the format `NNN:LLLLL:D`,
        /// <br/>(NNN: subnet, LLLLL: Route number, D: direction `H`/`R`). You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="filterPNLineSub">This parameter allows you to filter the returned items by specific routes. The route is provided in the format `NNN:LLLLL:E`,
        /// <br/>(NNN: subnet, LLLLL: Route number, E: supplement). You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of informational messages related to current or previous outages.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<AdditionalInfoResponse> RequestAsync(OutputFormat outputFormat, string filterDateValid, FilterMOTType? filterMOTType, FilterPublicationStatus? filterPublicationStatus, string itdLPxx_selStop, string itdLPxx_selLine, string itdLPxx_selOperator, string filterPNLineDir, string filterPNLineSub, string version)
        {
            return RequestAsync(outputFormat, filterDateValid, filterMOTType, filterPublicationStatus, itdLPxx_selStop, itdLPxx_selLine, itdLPxx_selOperator, filterPNLineDir, filterPNLineSub, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Provides capability to display all public transport service status and incident information (as published from the Service Alert Messaging System).
        /// </summary>
        /// <remarks>
        /// This endpoint returns a list of service alerts or additional information about travelling on the public transport
        /// <br/>network. This list can be filtered by date, route type, route, operator or stop.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="filterDateValid">This parameter allows you to filter the returned items that are only valid on the specified date. The format of
        /// <br/>this field is `DD-MM-YYYY`. For example, 12 September 2016 would be represented by `12-09-2016`.</param>
        /// <param name="filterMOTType">This parameter allows you to filter the returned items by the modes of transport they affected. Available modes include:
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>
        /// <br/>To search for more than one mode, include the parameter multiple times.</param>
        /// <param name="filterPublicationStatus">This field can be used so only current alerts are returned, and not historic alerts.</param>
        /// <param name="itdLPxx_selStop">This parameter allows you to filter the returned items by its stop ID or global stop ID. For example, to retrieve items that are only
        /// <br/>relevant to Central Station, you would set this value to `10111010` (stop ID) or `200060` (global stop ID). You can use the `stop_finder` API call
        /// <br/>to determine the ID for a particular stop.</param>
        /// <param name="itdLPxx_selLine">This parameter allows you to filter the returned items by line number. For example, `020T1`. You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="itdLPxx_selOperator">This parameter allows you to filter the returned items by operator ID. You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="filterPNLineDir">This parameter allows you to filter the returned items by specific routes. The route is provided in the format `NNN:LLLLL:D`,
        /// <br/>(NNN: subnet, LLLLL: Route number, D: direction `H`/`R`). You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="filterPNLineSub">This parameter allows you to filter the returned items by specific routes. The route is provided in the format `NNN:LLLLL:E`,
        /// <br/>(NNN: subnet, LLLLL: Route number, E: supplement). You can use this parameter
        /// <br/>multiple times if you want to search for more than one line number.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of informational messages related to current or previous outages.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<AdditionalInfoResponse> RequestAsync(OutputFormat outputFormat, string filterDateValid, FilterMOTType? filterMOTType, FilterPublicationStatus? filterPublicationStatus, string itdLPxx_selStop, string itdLPxx_selLine, string itdLPxx_selOperator, string filterPNLineDir, string filterPNLineSub, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (outputFormat == null)
                throw new System.ArgumentNullException("outputFormat");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "add_info"
                    urlBuilder_.Append("add_info");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("outputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (filterDateValid != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filterDateValid")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filterDateValid, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filterMOTType != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filterMOTType")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filterMOTType, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filterPublicationStatus != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filterPublicationStatus")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filterPublicationStatus, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdLPxx_selStop != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdLPxx_selStop")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdLPxx_selStop, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdLPxx_selLine != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdLPxx_selLine")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdLPxx_selLine, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdLPxx_selOperator != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdLPxx_selOperator")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdLPxx_selOperator, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filterPNLineDir != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filterPNLineDir")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filterPNLineDir, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (filterPNLineSub != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("filterPNLineSub")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(filterPNLineSub, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<AdditionalInfoResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The application calling the API has not been authenticated.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("An internal error has occurred.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The server is currently unavailable.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new TripPlannerException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CoordClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public CoordClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.transport.nsw.gov.au/v1/tp";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// When given a specific geographical location, this API finds public transport stops, stations, wharfs and points of interest around that location.
        /// </summary>
        /// <remarks>
        /// This endpoint returns places of interest based on the given coordinate and a radius. The types of POIs can be controlled, so if, for example,
        /// <br/>you only want Opal resellers returned, you can do so.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coord">The coordinate is in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).
        /// <br/>For example, the following `coord` value can be used to search around Central Station: `151.206290:-33.884080:EPSG:4326`.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="inclFilter">This enables "advanced filter mode" on the server, which is required to enable searching using coordinates.</param>
        /// <param name="type_1">This specifies the type of items to return.
        /// <br/>
        /// <br/>* `GIS_POINT`: GIS points, including Opal resellers (see `inclDrawClasses_1`)
        /// <br/>* `BUS_POINT`: Stops/stations
        /// <br/>* `POI_POINT`: Places of interest
        /// <br/>
        /// <br/>The `_1` suffix is an index for this particular filter. You can specify multiple filters by incrementing the suffix
        /// <br/>for each combination of `type`, `radius` and `inclDrawClasses`. For example, `type_1` means the first filter, `type_2`
        /// <br/>refers to the second, and so on.</param>
        /// <param name="radius_1">This indicates the maximum number of metres to search in all directions from the location specified in `coord`. For example,
        /// <br/>if you use a value of `500`, a `type_1` value of `GIS_POINT` and `inclDrawClasses_1` with a value of `74`, all Opal resellers
        /// <br/>within 500 metres will be returned. The suffix of `_1` indicates this radius value corresponds to the `type_1` value. If multiple
        /// <br/>filters are to be included, the appropriate suffix should be updated accordingly.</param>
        /// <param name="inclDrawClasses_1">This flag changes the list of POIs that are returned. To return Opal resellers, set this value to `74`
        /// <br/>and `type_1` to `GIS_POINT`.The suffix of `_1` indicates this radius value corresponds to the `type_1` value.
        /// <br/>If multiple filters are to be included, the appropriate suffix should be updated accordingly.</param>
        /// <param name="poisOnMapMacro">This field indicates how the returned data is to be used, which in turn impacts whether or not certain locations are returned.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of places of interest.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<CoordRequestResponse> RequestAsync(OutputFormat2 outputFormat, string coord, CoordOutputFormat coordOutputFormat, InclFilter inclFilter, Type_1 type_1, int radius_1, InclDrawClasses_1? inclDrawClasses_1, PoisOnMapMacro? poisOnMapMacro, string version)
        {
            return RequestAsync(outputFormat, coord, coordOutputFormat, inclFilter, type_1, radius_1, inclDrawClasses_1, poisOnMapMacro, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// When given a specific geographical location, this API finds public transport stops, stations, wharfs and points of interest around that location.
        /// </summary>
        /// <remarks>
        /// This endpoint returns places of interest based on the given coordinate and a radius. The types of POIs can be controlled, so if, for example,
        /// <br/>you only want Opal resellers returned, you can do so.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coord">The coordinate is in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).
        /// <br/>For example, the following `coord` value can be used to search around Central Station: `151.206290:-33.884080:EPSG:4326`.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="inclFilter">This enables "advanced filter mode" on the server, which is required to enable searching using coordinates.</param>
        /// <param name="type_1">This specifies the type of items to return.
        /// <br/>
        /// <br/>* `GIS_POINT`: GIS points, including Opal resellers (see `inclDrawClasses_1`)
        /// <br/>* `BUS_POINT`: Stops/stations
        /// <br/>* `POI_POINT`: Places of interest
        /// <br/>
        /// <br/>The `_1` suffix is an index for this particular filter. You can specify multiple filters by incrementing the suffix
        /// <br/>for each combination of `type`, `radius` and `inclDrawClasses`. For example, `type_1` means the first filter, `type_2`
        /// <br/>refers to the second, and so on.</param>
        /// <param name="radius_1">This indicates the maximum number of metres to search in all directions from the location specified in `coord`. For example,
        /// <br/>if you use a value of `500`, a `type_1` value of `GIS_POINT` and `inclDrawClasses_1` with a value of `74`, all Opal resellers
        /// <br/>within 500 metres will be returned. The suffix of `_1` indicates this radius value corresponds to the `type_1` value. If multiple
        /// <br/>filters are to be included, the appropriate suffix should be updated accordingly.</param>
        /// <param name="inclDrawClasses_1">This flag changes the list of POIs that are returned. To return Opal resellers, set this value to `74`
        /// <br/>and `type_1` to `GIS_POINT`.The suffix of `_1` indicates this radius value corresponds to the `type_1` value.
        /// <br/>If multiple filters are to be included, the appropriate suffix should be updated accordingly.</param>
        /// <param name="poisOnMapMacro">This field indicates how the returned data is to be used, which in turn impacts whether or not certain locations are returned.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of places of interest.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<CoordRequestResponse> RequestAsync(OutputFormat2 outputFormat, string coord, CoordOutputFormat coordOutputFormat, InclFilter inclFilter, Type_1 type_1, int radius_1, InclDrawClasses_1? inclDrawClasses_1, PoisOnMapMacro? poisOnMapMacro, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (outputFormat == null)
                throw new System.ArgumentNullException("outputFormat");

            if (coord == null)
                throw new System.ArgumentNullException("coord");

            if (coordOutputFormat == null)
                throw new System.ArgumentNullException("coordOutputFormat");

            if (inclFilter == null)
                throw new System.ArgumentNullException("inclFilter");

            if (type_1 == null)
                throw new System.ArgumentNullException("type_1");

            if (radius_1 == null)
                throw new System.ArgumentNullException("radius_1");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "coord"
                    urlBuilder_.Append("coord");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("outputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("coord")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coord, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("coordOutputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coordOutputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("inclFilter")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(inclFilter, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type_1")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type_1, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("radius_1")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(radius_1, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (inclDrawClasses_1 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("inclDrawClasses_1")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(inclDrawClasses_1, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (poisOnMapMacro != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("PoisOnMapMacro")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(poisOnMapMacro, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<CoordRequestResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The application calling the API has not been authenticated.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("An internal error has occurred.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The server is currently unavailable.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new TripPlannerException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DmClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public DmClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.transport.nsw.gov.au/v1/tp";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Provides capability to provide NSW public transport departure information from a stop, station or wharf including real-time.
        /// </summary>
        /// <remarks>
        /// This endpoint returns a list of departures for a given location based on the date and time specified. This data can be used to
        /// <br/>display a "upcoming departures" board for a stop.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="mode">This allows the departure board to display directly without going through the stop verification process. Use this when the stop is known.
        /// <br/>This relies on the given combination of `type_dm` and `name_dm` returning only a single result, otherwise a list of stops and no departures
        /// <br/>shall be returned.</param>
        /// <param name="type_dm">This specifies the type of results expected based on the search input in `name_dm`. By specifying `any`, locations of all types can be returned.
        /// <br/>Typically, this API call is used for a specific stop, so `stop` should be used along with a stop ID or global stop ID in `name_dm`.</param>
        /// <param name="name_dm">This is the search term that will be used to find locations. If the combination of this value and `type_dm` results in more than one
        /// <br/>location found - or `mode` is not set to `direct`, then a list of stops and no departures will be returned.
        /// <br/>If `type_dm` is set to `stop` then this value can take a stop ID or a global stop ID.</param>
        /// <param name="nameKey_dm">Setting this parameter to `$USEPOINT$` enables you to request departures for a specific platform within a station. If this isn't used,
        /// <br/>then departures for all platforms at the stop specified in `name_dm` are returned.</param>
        /// <param name="itdDate">The reference date used when searching trips, in `YYYYMMDD` format. For instance, 20160901 refers to
        /// <br/>1 September 2016. Works in conjunction with the `itdTime` value. If not specified, the current server date is used.</param>
        /// <param name="itdTime">The reference time used when searching trips, in `HHMM` 24-hour format. For instance, 2215 refers to 10:15 PM. |
        /// <br/>Works in conjunction with the `itdDate` value. If not specified, the current server time is used.</param>
        /// <param name="departureMonitorMacro">Including this parameter enables a number of options that result in the departure monitor operating in the same way
        /// <br/>as the Transport for NSW Trip Planner web site. It is recommended this is enabled, along with the
        /// <br/>`TfNSWDM` parameter.</param>
        /// <param name="excludedMeans">This parameter which means of transport to exclude from the departure monitor. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.</param>
        /// <param name="exclMOT_1">Excludes train services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_2">Excludes metro services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_4">Excludes light rail services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_5">Excludes bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_7">Excludes coach services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_9">Excludes ferry services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_11">Excludes school bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="tfNSWDM">Including this parameter enables a number of options that result in the departure monitor operating in the same way as the
        /// <br/>Transport for NSW Trip Planner web site, including enabling real-time data. It is recommended this is enabled,
        /// <br/>along with the `departureMonitorMacro` parameter.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of departures for the specified inputs</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<DepartureMonitorResponse> RequestAsync(OutputFormat3 outputFormat, CoordOutputFormat2 coordOutputFormat, Mode? mode, Type_dm type_dm, string name_dm, NameKey_dm? nameKey_dm, string itdDate, string itdTime, DepartureMonitorMacro? departureMonitorMacro, ExcludedMeans? excludedMeans, ExclMOT_1? exclMOT_1, ExclMOT_2? exclMOT_2, ExclMOT_4? exclMOT_4, ExclMOT_5? exclMOT_5, ExclMOT_7? exclMOT_7, ExclMOT_9? exclMOT_9, ExclMOT_11? exclMOT_11, TfNSWDM? tfNSWDM, string version)
        {
            return RequestAsync(outputFormat, coordOutputFormat, mode, type_dm, name_dm, nameKey_dm, itdDate, itdTime, departureMonitorMacro, excludedMeans, exclMOT_1, exclMOT_2, exclMOT_4, exclMOT_5, exclMOT_7, exclMOT_9, exclMOT_11, tfNSWDM, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Provides capability to provide NSW public transport departure information from a stop, station or wharf including real-time.
        /// </summary>
        /// <remarks>
        /// This endpoint returns a list of departures for a given location based on the date and time specified. This data can be used to
        /// <br/>display a "upcoming departures" board for a stop.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="mode">This allows the departure board to display directly without going through the stop verification process. Use this when the stop is known.
        /// <br/>This relies on the given combination of `type_dm` and `name_dm` returning only a single result, otherwise a list of stops and no departures
        /// <br/>shall be returned.</param>
        /// <param name="type_dm">This specifies the type of results expected based on the search input in `name_dm`. By specifying `any`, locations of all types can be returned.
        /// <br/>Typically, this API call is used for a specific stop, so `stop` should be used along with a stop ID or global stop ID in `name_dm`.</param>
        /// <param name="name_dm">This is the search term that will be used to find locations. If the combination of this value and `type_dm` results in more than one
        /// <br/>location found - or `mode` is not set to `direct`, then a list of stops and no departures will be returned.
        /// <br/>If `type_dm` is set to `stop` then this value can take a stop ID or a global stop ID.</param>
        /// <param name="nameKey_dm">Setting this parameter to `$USEPOINT$` enables you to request departures for a specific platform within a station. If this isn't used,
        /// <br/>then departures for all platforms at the stop specified in `name_dm` are returned.</param>
        /// <param name="itdDate">The reference date used when searching trips, in `YYYYMMDD` format. For instance, 20160901 refers to
        /// <br/>1 September 2016. Works in conjunction with the `itdTime` value. If not specified, the current server date is used.</param>
        /// <param name="itdTime">The reference time used when searching trips, in `HHMM` 24-hour format. For instance, 2215 refers to 10:15 PM. |
        /// <br/>Works in conjunction with the `itdDate` value. If not specified, the current server time is used.</param>
        /// <param name="departureMonitorMacro">Including this parameter enables a number of options that result in the departure monitor operating in the same way
        /// <br/>as the Transport for NSW Trip Planner web site. It is recommended this is enabled, along with the
        /// <br/>`TfNSWDM` parameter.</param>
        /// <param name="excludedMeans">This parameter which means of transport to exclude from the departure monitor. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.</param>
        /// <param name="exclMOT_1">Excludes train services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_2">Excludes metro services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_4">Excludes light rail services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_5">Excludes bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_7">Excludes coach services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_9">Excludes ferry services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_11">Excludes school bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="tfNSWDM">Including this parameter enables a number of options that result in the departure monitor operating in the same way as the
        /// <br/>Transport for NSW Trip Planner web site, including enabling real-time data. It is recommended this is enabled,
        /// <br/>along with the `departureMonitorMacro` parameter.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of departures for the specified inputs</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<DepartureMonitorResponse> RequestAsync(OutputFormat3 outputFormat, CoordOutputFormat2 coordOutputFormat, Mode? mode, Type_dm type_dm, string name_dm, NameKey_dm? nameKey_dm, string itdDate, string itdTime, DepartureMonitorMacro? departureMonitorMacro, ExcludedMeans? excludedMeans, ExclMOT_1? exclMOT_1, ExclMOT_2? exclMOT_2, ExclMOT_4? exclMOT_4, ExclMOT_5? exclMOT_5, ExclMOT_7? exclMOT_7, ExclMOT_9? exclMOT_9, ExclMOT_11? exclMOT_11, TfNSWDM? tfNSWDM, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (outputFormat == null)
                throw new System.ArgumentNullException("outputFormat");

            if (coordOutputFormat == null)
                throw new System.ArgumentNullException("coordOutputFormat");

            if (type_dm == null)
                throw new System.ArgumentNullException("type_dm");

            if (name_dm == null)
                throw new System.ArgumentNullException("name_dm");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "departure_mon"
                    urlBuilder_.Append("departure_mon");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("outputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("coordOutputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coordOutputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (mode != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("mode")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(mode, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Append(System.Uri.EscapeDataString("type_dm")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type_dm, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name_dm")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name_dm, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (nameKey_dm != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("nameKey_dm")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(nameKey_dm, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdDate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdDate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdDate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdTime != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdTime")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdTime, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (departureMonitorMacro != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("departureMonitorMacro")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(departureMonitorMacro, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (excludedMeans != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("excludedMeans")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(excludedMeans, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_1 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_1")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_1, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_2 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_2")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_2, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_4 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_4")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_4, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_5 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_5")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_5, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_7 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_7")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_7, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_9 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_9")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_9, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_11 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_11")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_11, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tfNSWDM != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("TfNSWDM")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tfNSWDM, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<DepartureMonitorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The application calling the API has not been authenticated.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("An internal error has occurred.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The server is currently unavailable.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new TripPlannerException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StopfinderClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public StopfinderClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.transport.nsw.gov.au/v1/tp";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Provides capability to return all NSW public transport stop, station, wharf, points of interest and known addresses to be used for auto-suggest/auto-complete (to be used with the Trip planner and Departure board APIs).
        /// </summary>
        /// <remarks>
        /// This endpoint returns info about stops that match the search criteria. Matches can be sorted on `matchQuality` to determine the best matches for the given input,
        /// <br/>while the best match will be indicated by the `isBest` value.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="type_sf">This specifies the type of results expected in the list of returned stops. By specifying `any`, locations of all types can be returned.
        /// <br/>If you specifically know that you're searching using a coord, specify `coord`. Likewise, if you're using a stop ID or global stop ID as an input, use `stop`
        /// <br/>for more accurate results.</param>
        /// <param name="name_sf">This is the search term that will be used to find locations.
        /// <br/>To lookup a coordinate, set `type_sf` to `coord`, and use the following format:
        /// <br/>`LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first). For example, `151.206290:-33.884080:EPSG:4326`.
        /// <br/>To lookup a stop set `type_sf` to  `stop` and enter the stop id or global stop ID. For example, `10101100`</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="tfNSWSF">Including this parameter enables a number of options that result in the stop finder operating in the same way as the Transport for NSW Trip Planner web site.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of stops and locations that can be used in trip planner requests. Invalid parameters do not generate an error response. Rather, the response may simply contain 0 or more locations.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<StopFinderResponse> RequestAsync(OutputFormat4 outputFormat, Type_sf? type_sf, string name_sf, CoordOutputFormat3 coordOutputFormat, TfNSWSF? tfNSWSF, string version)
        {
            return RequestAsync(outputFormat, type_sf, name_sf, coordOutputFormat, tfNSWSF, version, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Provides capability to return all NSW public transport stop, station, wharf, points of interest and known addresses to be used for auto-suggest/auto-complete (to be used with the Trip planner and Departure board APIs).
        /// </summary>
        /// <remarks>
        /// This endpoint returns info about stops that match the search criteria. Matches can be sorted on `matchQuality` to determine the best matches for the given input,
        /// <br/>while the best match will be indicated by the `isBest` value.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="type_sf">This specifies the type of results expected in the list of returned stops. By specifying `any`, locations of all types can be returned.
        /// <br/>If you specifically know that you're searching using a coord, specify `coord`. Likewise, if you're using a stop ID or global stop ID as an input, use `stop`
        /// <br/>for more accurate results.</param>
        /// <param name="name_sf">This is the search term that will be used to find locations.
        /// <br/>To lookup a coordinate, set `type_sf` to `coord`, and use the following format:
        /// <br/>`LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first). For example, `151.206290:-33.884080:EPSG:4326`.
        /// <br/>To lookup a stop set `type_sf` to  `stop` and enter the stop id or global stop ID. For example, `10101100`</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="tfNSWSF">Including this parameter enables a number of options that result in the stop finder operating in the same way as the Transport for NSW Trip Planner web site.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <returns>A list of stops and locations that can be used in trip planner requests. Invalid parameters do not generate an error response. Rather, the response may simply contain 0 or more locations.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<StopFinderResponse> RequestAsync(OutputFormat4 outputFormat, Type_sf? type_sf, string name_sf, CoordOutputFormat3 coordOutputFormat, TfNSWSF? tfNSWSF, string version, System.Threading.CancellationToken cancellationToken)
        {
            if (outputFormat == null)
                throw new System.ArgumentNullException("outputFormat");

            if (name_sf == null)
                throw new System.ArgumentNullException("name_sf");

            if (coordOutputFormat == null)
                throw new System.ArgumentNullException("coordOutputFormat");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "stop_finder"
                    urlBuilder_.Append("stop_finder");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("outputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (type_sf != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("type_sf")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type_sf, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Append(System.Uri.EscapeDataString("name_sf")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name_sf, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("coordOutputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coordOutputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (tfNSWSF != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("TfNSWSF")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tfNSWSF, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<StopFinderResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The application calling the API has not been authenticated.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("An internal error has occurred.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The server is currently unavailable.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new TripPlannerException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripClient 
    {
        #pragma warning disable 8618
        private string _baseUrl;
        #pragma warning restore 8618

        private System.Net.Http.HttpClient _httpClient;
        private static System.Lazy<System.Text.Json.JsonSerializerOptions> _settings = new System.Lazy<System.Text.Json.JsonSerializerOptions>(CreateSerializerSettings, true);
        private System.Text.Json.JsonSerializerOptions _instanceSettings;

    #pragma warning disable CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        public TripClient(System.Net.Http.HttpClient httpClient)
    #pragma warning restore CS8618 // Non-nullable field must contain a non-null value when exiting constructor. Consider declaring as nullable.
        {
            BaseUrl = "https://api.transport.nsw.gov.au/v1/tp";
            _httpClient = httpClient;
            Initialize();
        }

        private static System.Text.Json.JsonSerializerOptions CreateSerializerSettings()
        {
            var settings = new System.Text.Json.JsonSerializerOptions();
            UpdateJsonSerializerSettings(settings);
            return settings;
        }

        public string BaseUrl
        {
            get { return _baseUrl; }
            set
            {
                _baseUrl = value;
                if (!string.IsNullOrEmpty(_baseUrl) && !_baseUrl.EndsWith("/"))
                    _baseUrl += '/';
            }
        }

        protected System.Text.Json.JsonSerializerOptions JsonSerializerSettings { get { return _instanceSettings ?? _settings.Value; } }

        static partial void UpdateJsonSerializerSettings(System.Text.Json.JsonSerializerOptions settings);

        partial void Initialize();

        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, string url);
        partial void PrepareRequest(System.Net.Http.HttpClient client, System.Net.Http.HttpRequestMessage request, System.Text.StringBuilder urlBuilder);
        partial void ProcessResponse(System.Net.Http.HttpClient client, System.Net.Http.HttpResponseMessage response);

        /// <summary>
        /// Provides capability to provide NSW public transport trip plan options, including walking and driving legs and real-time information.
        /// </summary>
        /// <remarks>
        /// This endpoint is used to find a list of journeys between two locations at the specified date and time. For example,
        /// <br/>if the user is at the Airport and wants to get to Manly using public transport but isn't sure how exactly, this call
        /// <br/>will tell them exactly which train, bus, ferry or light rail to catch, and between which stops. It is extremely detailed,
        /// <br/>and includes the the specific path the vehicle(s) will take.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="depArrMacro">This value anchors the requested date time. If set to `dep`, then trips *departing after* the specified date/time
        /// <br/>*at the specified location* are included.
        /// <br/>If set to `arr`, then trips *arriving before* the specified time *at its destination stop* are included. Works in conjunctions with the
        /// <br/>`itdDate` and `itdTime` values.</param>
        /// <param name="itdDate">The reference date used when searching trips, in `YYYYMMDD` format. For instance, `20160901` refers to
        /// <br/>1 September 2016. Works in conjunction with the `itdTime` and `depArrMacro` values. If not specified, the current server date is used.</param>
        /// <param name="itdTime">The reference time used when searching trips, in `HHMM` 24-hour format. For instance, `2215` refers to 10:15 PM. |
        /// <br/>Works in conjunction with the `itdDate` and `depArrMacro` values. If not specified, the current server time is used.</param>
        /// <param name="type_origin">This is the type of data specified in the `name_origin` field. The origin indicates the starting point when searching for journeys.
        /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_origin`, or to use `coord`
        /// <br/>in this field and a correctly formatted coordinate in `type_origin`.</param>
        /// <param name="name_origin">This value is used to indicate the starting point when searching for journeys.
        /// <br/>This value can be one of three things:
        /// <br/>A valid location/stop ID (for example, `10101100` indicates Central Station - this can be determined using `stop_finder`).
        /// <br/>A valid global stop ID (for example, `200060` indicates Central Station - this can be determined using `stop_finder`)
        /// <br/>Coordinates in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).</param>
        /// <param name="type_destination">This is the type of data specified in the `name_destination` field. The origin indicates the finishing point when searching for journeys.
        /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_destination`, or to use `coord`
        /// <br/>in this field and a correctly formatted coordinate in `type_destination`.</param>
        /// <param name="name_destination">This value is used to indicate the finishing point when searching for journeys.
        /// <br/>This value can be one of three things:
        /// <br/>A valid location/stop ID (for example, `10101100` indicates Central Station - this can be determined using `stop_finder`).
        /// <br/>A valid global stop ID (for example, `200060` indicates Central Station - this can be determined using `stop_finder`)
        /// <br/>Coordinates in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).</param>
        /// <param name="calcNumberOfTrips">This parameter indicates the maximum number of trips to returned. Fewer trips may be returned anyway,
        /// <br/>depending on the available public transport services.</param>
        /// <param name="wheelchair">Including this parameter (regardless of its value) ensures that only wheelchair-accessible options are returned.</param>
        /// <param name="excludedMeans">This parameter which means of transport to exclude from the trip plan. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.</param>
        /// <param name="exclMOT_1">Excludes train services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_2">Excludes metro services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_4">Excludes light rail services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_5">Excludes bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_7">Excludes coach services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_9">Excludes ferry services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_11">Excludes school bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="tfNSWTR">Including this parameter enables a number of options that result in this API call operating in the same way as the Transport for NSW Trip Planner web site, including enabling real-time data.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <param name="itOptionsActive">This parameter activates the options for individual transport. If the parameter is disabled, the parameters concerning individual transport will not be taken into account. possible values are 0 and 1</param>
        /// <param name="computeMonomodalTripBicycle">Activates the calculation of a monomodal trip, i.e., a trip that takes place exclusively with the means of transport &lt;means of transport&gt;, e.g., with bicycle. Note 1: In order to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Note 2: If no monomodal trip with the means of transport &lt;means of transport&gt; is calculated despite the parameter, the maximum time is often set too low. The parameter MaxITTime applies to all means of transport, the parameter MaxITTime&lt;means of transport&gt;to the means of transport &lt;means of transport&gt; (e.g., MaxITTime107). These parameters are located in the [Parameters] section or are added to it. The configuration can be alternatively overridden bythe maxTime&lt;Transport means&gt; parameter.</param>
        /// <param name="cycleSpeed">The value of the &lt;speed&gt; parameter is used to specify the speed of cycle travel in kilometers per hour.Note: In order to use this parameter, the options for individual transport must be activated with itOptionsActive=1. If the parameter is to be specified together with a profile, the bikeProfSpeed parameter can be used.The parameter 'cycleSpeed specifies the desired real speed of the user for the bike route, which overwrites the speed in the SpeedSettings of the corresponding bikeProfSpeed.</param>
        /// <param name="bikeProfSpeed">With the parameter 'bikeProfSpeed' a bike profile name is passed</param>
        /// <param name="maxTimeBicycle">The value of the this parameter sets the maximum time to be covered by the means of cycling. The time is specified in minutes. Note: To use this parameter, the options for individual transport must be enabled with itOptionsActive=1</param>
        /// <param name="onlyITBicycle">Restricts the calculation to trips with the bikes only. Note: To be able to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Possible values are 1, true, on</param>
        /// <param name="useElevationData">If this parameter is active, the elevation data is taken into account in the trip calculation for all means of transport and output in a route description for each individual transport section. Note: To be able to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Possible values are 1, true, on</param>
        /// <param name="elevFac">This parameter specifies the maximum slope for bike routes. Roads with a slope greater than the specified?? one are avoided. The slope is specified by a factor &lt;factor&gt; whose value range is [0..100]. By default, the value of the parameter is 50</param>
        /// <returns>A list of suggested journeys.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual System.Threading.Tasks.Task<TripRequestResponse> Request2Async(OutputFormat5 outputFormat, CoordOutputFormat4 coordOutputFormat, DepArrMacro depArrMacro, string itdDate, string itdTime, Type_origin type_origin, string name_origin, Type_destination type_destination, string name_destination, int? calcNumberOfTrips, Wheelchair? wheelchair, ExcludedMeans2? excludedMeans, ExclMOT_12? exclMOT_1, ExclMOT_22? exclMOT_2, ExclMOT_42? exclMOT_4, ExclMOT_52? exclMOT_5, ExclMOT_72? exclMOT_7, ExclMOT_92? exclMOT_9, ExclMOT_112? exclMOT_11, TfNSWTR? tfNSWTR, string version, int? itOptionsActive, bool? computeMonomodalTripBicycle, int? cycleSpeed, BikeProfSpeed? bikeProfSpeed, int? maxTimeBicycle, int? onlyITBicycle, int? useElevationData, int? elevFac)
        {
            return Request2Async(outputFormat, coordOutputFormat, depArrMacro, itdDate, itdTime, type_origin, name_origin, type_destination, name_destination, calcNumberOfTrips, wheelchair, excludedMeans, exclMOT_1, exclMOT_2, exclMOT_4, exclMOT_5, exclMOT_7, exclMOT_9, exclMOT_11, tfNSWTR, version, itOptionsActive, computeMonomodalTripBicycle, cycleSpeed, bikeProfSpeed, maxTimeBicycle, onlyITBicycle, useElevationData, elevFac, System.Threading.CancellationToken.None);
        }

        /// <param name="cancellationToken">A cancellation token that can be used by other objects or threads to receive notice of cancellation.</param>
        /// <summary>
        /// Provides capability to provide NSW public transport trip plan options, including walking and driving legs and real-time information.
        /// </summary>
        /// <remarks>
        /// This endpoint is used to find a list of journeys between two locations at the specified date and time. For example,
        /// <br/>if the user is at the Airport and wants to get to Manly using public transport but isn't sure how exactly, this call
        /// <br/>will tell them exactly which train, bus, ferry or light rail to catch, and between which stops. It is extremely detailed,
        /// <br/>and includes the the specific path the vehicle(s) will take.
        /// </remarks>
        /// <param name="outputFormat">Used to set the response data type. This documentation only covers responses that use the JSON format.
        /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.</param>
        /// <param name="coordOutputFormat">This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.</param>
        /// <param name="depArrMacro">This value anchors the requested date time. If set to `dep`, then trips *departing after* the specified date/time
        /// <br/>*at the specified location* are included.
        /// <br/>If set to `arr`, then trips *arriving before* the specified time *at its destination stop* are included. Works in conjunctions with the
        /// <br/>`itdDate` and `itdTime` values.</param>
        /// <param name="itdDate">The reference date used when searching trips, in `YYYYMMDD` format. For instance, `20160901` refers to
        /// <br/>1 September 2016. Works in conjunction with the `itdTime` and `depArrMacro` values. If not specified, the current server date is used.</param>
        /// <param name="itdTime">The reference time used when searching trips, in `HHMM` 24-hour format. For instance, `2215` refers to 10:15 PM. |
        /// <br/>Works in conjunction with the `itdDate` and `depArrMacro` values. If not specified, the current server time is used.</param>
        /// <param name="type_origin">This is the type of data specified in the `name_origin` field. The origin indicates the starting point when searching for journeys.
        /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_origin`, or to use `coord`
        /// <br/>in this field and a correctly formatted coordinate in `type_origin`.</param>
        /// <param name="name_origin">This value is used to indicate the starting point when searching for journeys.
        /// <br/>This value can be one of three things:
        /// <br/>A valid location/stop ID (for example, `10101100` indicates Central Station - this can be determined using `stop_finder`).
        /// <br/>A valid global stop ID (for example, `200060` indicates Central Station - this can be determined using `stop_finder`)
        /// <br/>Coordinates in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).</param>
        /// <param name="type_destination">This is the type of data specified in the `name_destination` field. The origin indicates the finishing point when searching for journeys.
        /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_destination`, or to use `coord`
        /// <br/>in this field and a correctly formatted coordinate in `type_destination`.</param>
        /// <param name="name_destination">This value is used to indicate the finishing point when searching for journeys.
        /// <br/>This value can be one of three things:
        /// <br/>A valid location/stop ID (for example, `10101100` indicates Central Station - this can be determined using `stop_finder`).
        /// <br/>A valid global stop ID (for example, `200060` indicates Central Station - this can be determined using `stop_finder`)
        /// <br/>Coordinates in the format `LONGITUDE:LATITUDE:EPSG:4326` (Note that longitude is first).</param>
        /// <param name="calcNumberOfTrips">This parameter indicates the maximum number of trips to returned. Fewer trips may be returned anyway,
        /// <br/>depending on the available public transport services.</param>
        /// <param name="wheelchair">Including this parameter (regardless of its value) ensures that only wheelchair-accessible options are returned.</param>
        /// <param name="excludedMeans">This parameter which means of transport to exclude from the trip plan. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.</param>
        /// <param name="exclMOT_1">Excludes train services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_2">Excludes metro services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_4">Excludes light rail services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_5">Excludes bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_7">Excludes coach services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_9">Excludes ferry services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="exclMOT_11">Excludes school bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`</param>
        /// <param name="tfNSWTR">Including this parameter enables a number of options that result in this API call operating in the same way as the Transport for NSW Trip Planner web site, including enabling real-time data.</param>
        /// <param name="version">Indicates which version of the API the caller is expecting for both request and response data. Note that if this version differs
        /// <br/>from the version listed above then the returned data may not be as expected.</param>
        /// <param name="itOptionsActive">This parameter activates the options for individual transport. If the parameter is disabled, the parameters concerning individual transport will not be taken into account. possible values are 0 and 1</param>
        /// <param name="computeMonomodalTripBicycle">Activates the calculation of a monomodal trip, i.e., a trip that takes place exclusively with the means of transport &lt;means of transport&gt;, e.g., with bicycle. Note 1: In order to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Note 2: If no monomodal trip with the means of transport &lt;means of transport&gt; is calculated despite the parameter, the maximum time is often set too low. The parameter MaxITTime applies to all means of transport, the parameter MaxITTime&lt;means of transport&gt;to the means of transport &lt;means of transport&gt; (e.g., MaxITTime107). These parameters are located in the [Parameters] section or are added to it. The configuration can be alternatively overridden bythe maxTime&lt;Transport means&gt; parameter.</param>
        /// <param name="cycleSpeed">The value of the &lt;speed&gt; parameter is used to specify the speed of cycle travel in kilometers per hour.Note: In order to use this parameter, the options for individual transport must be activated with itOptionsActive=1. If the parameter is to be specified together with a profile, the bikeProfSpeed parameter can be used.The parameter 'cycleSpeed specifies the desired real speed of the user for the bike route, which overwrites the speed in the SpeedSettings of the corresponding bikeProfSpeed.</param>
        /// <param name="bikeProfSpeed">With the parameter 'bikeProfSpeed' a bike profile name is passed</param>
        /// <param name="maxTimeBicycle">The value of the this parameter sets the maximum time to be covered by the means of cycling. The time is specified in minutes. Note: To use this parameter, the options for individual transport must be enabled with itOptionsActive=1</param>
        /// <param name="onlyITBicycle">Restricts the calculation to trips with the bikes only. Note: To be able to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Possible values are 1, true, on</param>
        /// <param name="useElevationData">If this parameter is active, the elevation data is taken into account in the trip calculation for all means of transport and output in a route description for each individual transport section. Note: To be able to use this parameter, the options for individual transport must be activated with itOptionsActive=1. Possible values are 1, true, on</param>
        /// <param name="elevFac">This parameter specifies the maximum slope for bike routes. Roads with a slope greater than the specified?? one are avoided. The slope is specified by a factor &lt;factor&gt; whose value range is [0..100]. By default, the value of the parameter is 50</param>
        /// <returns>A list of suggested journeys.</returns>
        /// <exception cref="TripPlannerException">A server side error occurred.</exception>
        public virtual async System.Threading.Tasks.Task<TripRequestResponse> Request2Async(OutputFormat5 outputFormat, CoordOutputFormat4 coordOutputFormat, DepArrMacro depArrMacro, string itdDate, string itdTime, Type_origin type_origin, string name_origin, Type_destination type_destination, string name_destination, int? calcNumberOfTrips, Wheelchair? wheelchair, ExcludedMeans2? excludedMeans, ExclMOT_12? exclMOT_1, ExclMOT_22? exclMOT_2, ExclMOT_42? exclMOT_4, ExclMOT_52? exclMOT_5, ExclMOT_72? exclMOT_7, ExclMOT_92? exclMOT_9, ExclMOT_112? exclMOT_11, TfNSWTR? tfNSWTR, string version, int? itOptionsActive, bool? computeMonomodalTripBicycle, int? cycleSpeed, BikeProfSpeed? bikeProfSpeed, int? maxTimeBicycle, int? onlyITBicycle, int? useElevationData, int? elevFac, System.Threading.CancellationToken cancellationToken)
        {
            if (outputFormat == null)
                throw new System.ArgumentNullException("outputFormat");

            if (coordOutputFormat == null)
                throw new System.ArgumentNullException("coordOutputFormat");

            if (depArrMacro == null)
                throw new System.ArgumentNullException("depArrMacro");

            if (type_origin == null)
                throw new System.ArgumentNullException("type_origin");

            if (name_origin == null)
                throw new System.ArgumentNullException("name_origin");

            if (type_destination == null)
                throw new System.ArgumentNullException("type_destination");

            if (name_destination == null)
                throw new System.ArgumentNullException("name_destination");

            var client_ = _httpClient;
            var disposeClient_ = false;
            try
            {
                using (var request_ = new System.Net.Http.HttpRequestMessage())
                {
                    request_.Method = new System.Net.Http.HttpMethod("GET");
                    request_.Headers.Accept.Add(System.Net.Http.Headers.MediaTypeWithQualityHeaderValue.Parse("application/json"));

                    var urlBuilder_ = new System.Text.StringBuilder();
                    if (!string.IsNullOrEmpty(_baseUrl)) urlBuilder_.Append(_baseUrl);
                    // Operation Path: "trip"
                    urlBuilder_.Append("trip");
                    urlBuilder_.Append('?');
                    urlBuilder_.Append(System.Uri.EscapeDataString("outputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(outputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("coordOutputFormat")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(coordOutputFormat, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("depArrMacro")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(depArrMacro, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (itdDate != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdDate")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdDate, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itdTime != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itdTime")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itdTime, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Append(System.Uri.EscapeDataString("type_origin")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type_origin, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name_origin")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name_origin, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("type_destination")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(type_destination, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    urlBuilder_.Append(System.Uri.EscapeDataString("name_destination")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(name_destination, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    if (calcNumberOfTrips != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("calcNumberOfTrips")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(calcNumberOfTrips, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (wheelchair != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("wheelchair")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(wheelchair, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (excludedMeans != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("excludedMeans")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(excludedMeans, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_1 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_1")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_1, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_2 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_2")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_2, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_4 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_4")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_4, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_5 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_5")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_5, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_7 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_7")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_7, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_9 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_9")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_9, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (exclMOT_11 != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("exclMOT_11")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(exclMOT_11, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (tfNSWTR != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("TfNSWTR")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(tfNSWTR, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (version != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("version")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(version, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (itOptionsActive != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("itOptionsActive")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(itOptionsActive, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (computeMonomodalTripBicycle != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("computeMonomodalTripBicycle")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(computeMonomodalTripBicycle, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (cycleSpeed != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("cycleSpeed")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(cycleSpeed, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (bikeProfSpeed != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("bikeProfSpeed")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(bikeProfSpeed, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (maxTimeBicycle != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("maxTimeBicycle")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(maxTimeBicycle, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (onlyITBicycle != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("onlyITBicycle")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(onlyITBicycle, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (useElevationData != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("useElevationData")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(useElevationData, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    if (elevFac != null)
                    {
                        urlBuilder_.Append(System.Uri.EscapeDataString("elevFac")).Append('=').Append(System.Uri.EscapeDataString(ConvertToString(elevFac, System.Globalization.CultureInfo.InvariantCulture))).Append('&');
                    }
                    urlBuilder_.Length--;

                    PrepareRequest(client_, request_, urlBuilder_);

                    var url_ = urlBuilder_.ToString();
                    request_.RequestUri = new System.Uri(url_, System.UriKind.RelativeOrAbsolute);

                    PrepareRequest(client_, request_, url_);

                    var response_ = await client_.SendAsync(request_, System.Net.Http.HttpCompletionOption.ResponseHeadersRead, cancellationToken).ConfigureAwait(false);
                    var disposeResponse_ = true;
                    try
                    {
                        var headers_ = new System.Collections.Generic.Dictionary<string, System.Collections.Generic.IEnumerable<string>>();
                        foreach (var item_ in response_.Headers)
                            headers_[item_.Key] = item_.Value;
                        if (response_.Content != null && response_.Content.Headers != null)
                        {
                            foreach (var item_ in response_.Content.Headers)
                                headers_[item_.Key] = item_.Value;
                        }

                        ProcessResponse(client_, response_);

                        var status_ = (int)response_.StatusCode;
                        if (status_ == 200)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<TripRequestResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            return objectResponse_.Object;
                        }
                        else
                        if (status_ == 401)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The application calling the API has not been authenticated.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 500)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("An internal error has occurred.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        if (status_ == 503)
                        {
                            var objectResponse_ = await ReadObjectResponseAsync<HttpErrorResponse>(response_, headers_, cancellationToken).ConfigureAwait(false);
                            if (objectResponse_.Object == null)
                            {
                                throw new TripPlannerException("Response was null which was not expected.", status_, objectResponse_.Text, headers_, null);
                            }
                            throw new TripPlannerException<HttpErrorResponse>("The server is currently unavailable.", status_, objectResponse_.Text, headers_, objectResponse_.Object, null);
                        }
                        else
                        {
                            var responseData_ = response_.Content == null ? null : await ReadAsStringAsync(response_.Content, cancellationToken).ConfigureAwait(false);
                            throw new TripPlannerException("The HTTP status code of the response was not expected (" + status_ + ").", status_, responseData_, headers_, null);
                        }
                    }
                    finally
                    {
                        if (disposeResponse_)
                            response_.Dispose();
                    }
                }
            }
            finally
            {
                if (disposeClient_)
                    client_.Dispose();
            }
        }

        protected struct ObjectResponseResult<T>
        {
            public ObjectResponseResult(T responseObject, string responseText)
            {
                this.Object = responseObject;
                this.Text = responseText;
            }

            public T Object { get; }

            public string Text { get; }
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<string> ReadAsStringAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStringAsync(cancellationToken);
    #else
            return content.ReadAsStringAsync();
    #endif
        }

        [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
        private static System.Threading.Tasks.Task<System.IO.Stream> ReadAsStreamAsync(System.Net.Http.HttpContent content, System.Threading.CancellationToken cancellationToken)
        {
    #if NET5_0_OR_GREATER
            return content.ReadAsStreamAsync(cancellationToken);
    #else
            return content.ReadAsStreamAsync();
    #endif
        }

        public bool ReadResponseAsString { get; set; }

        protected virtual async System.Threading.Tasks.Task<ObjectResponseResult<T>> ReadObjectResponseAsync<T>(System.Net.Http.HttpResponseMessage response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Threading.CancellationToken cancellationToken)
        {
            if (response == null || response.Content == null)
            {
                return new ObjectResponseResult<T>(default(T), string.Empty);
            }

            if (ReadResponseAsString)
            {
                var responseText = await ReadAsStringAsync(response.Content, cancellationToken).ConfigureAwait(false);
                try
                {
                    var typedBody = System.Text.Json.JsonSerializer.Deserialize<T>(responseText, JsonSerializerSettings);
                    return new ObjectResponseResult<T>(typedBody, responseText);
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body string as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, responseText, headers, exception);
                }
            }
            else
            {
                try
                {
                    using (var responseStream = await ReadAsStreamAsync(response.Content, cancellationToken).ConfigureAwait(false))
                    {
                        var typedBody = await System.Text.Json.JsonSerializer.DeserializeAsync<T>(responseStream, JsonSerializerSettings, cancellationToken).ConfigureAwait(false);
                        return new ObjectResponseResult<T>(typedBody, string.Empty);
                    }
                }
                catch (System.Text.Json.JsonException exception)
                {
                    var message = "Could not deserialize the response body stream as " + typeof(T).FullName + ".";
                    throw new TripPlannerException(message, (int)response.StatusCode, string.Empty, headers, exception);
                }
            }
        }

        private string ConvertToString(object value, System.Globalization.CultureInfo cultureInfo)
        {
            if (value == null)
            {
                return "";
            }

            if (value is System.Enum)
            {
                var name = System.Enum.GetName(value.GetType(), value);
                if (name != null)
                {
                    var field = System.Reflection.IntrospectionExtensions.GetTypeInfo(value.GetType()).GetDeclaredField(name);
                    if (field != null)
                    {
                        var attribute = System.Reflection.CustomAttributeExtensions.GetCustomAttribute(field, typeof(System.Runtime.Serialization.EnumMemberAttribute)) 
                            as System.Runtime.Serialization.EnumMemberAttribute;
                        if (attribute != null)
                        {
                            return attribute.Value != null ? attribute.Value : name;
                        }
                    }

                    var converted = System.Convert.ToString(System.Convert.ChangeType(value, System.Enum.GetUnderlyingType(value.GetType()), cultureInfo));
                    return converted == null ? string.Empty : converted;
                }
            }
            else if (value is bool) 
            {
                return System.Convert.ToString((bool)value, cultureInfo).ToLowerInvariant();
            }
            else if (value is byte[])
            {
                return System.Convert.ToBase64String((byte[]) value);
            }
            else if (value is string[])
            {
                return string.Join(",", (string[])value);
            }
            else if (value.GetType().IsArray)
            {
                var valueArray = (System.Array)value;
                var valueTextArray = new string[valueArray.Length];
                for (var i = 0; i < valueArray.Length; i++)
                {
                    valueTextArray[i] = ConvertToString(valueArray.GetValue(i), cultureInfo);
                }
                return string.Join(",", valueTextArray);
            }

            var result = System.Convert.ToString(value, cultureInfo);
            return result == null ? "" : result;
        }
    }

    /// <summary>
    /// This is the response data returned when performing an `add_info` request.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionalInfoResponse
    {

        /// <summary>
        /// If an error has occurred, this element contains information about the error.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public ApiErrorResponse Error { get; set; }

        /// <summary>
        /// Contains each of the returned service alerts.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("infos")]
        public Infos Infos { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("timestamp")]
        public string Timestamp { get; set; }

        /// <summary>
        /// The version of the API that provided the response. Note that if this value is different to above, then the returned data may be
        /// <br/>different than expected. You can set the expected version using the `version` request parameter.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public string Version { get; set; }

    }

    /// <summary>
    /// This element describes a single route that is affected by a service alert.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionalInfoResponseAffectedLine
    {

        /// <summary>
        /// This element describes the destination of trips fulfilled by the given line.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination")]
        public Destination Destination { get; set; }

        /// <summary>
        /// This is the unique ID that identifies the given line.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the full name of the route.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// This is the short name or code of the route.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("number")]
        public string Number { get; set; }

        /// <summary>
        /// This element contains additional properties about the route.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("product")]
        public RouteProduct Product { get; set; }

    }

    /// <summary>
    /// This element describes a single stop that is affected by a service alert.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionalInfoResponseAffectedStop
    {

        /// <summary>
        /// This the unique ID of the stop that is affected. It is the same ID that is
        /// <br/>used elsewhere in the system, such as in `trip` or
        /// <br/>`stop_finder`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the title of the affected stop.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// If available, contains information about this location's parent location. For example, if the
        /// <br/>stop has a type of `platform`, then this field may contain information about the station in which
        /// <br/>the platform is located.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// The type of the location that is affected.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AdditionalInfoResponseAffectedStopType? Type { get; set; }

    }

    /// <summary>
    /// This element describes a single service alert.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionalInfoResponseMessage
    {

        /// <summary>
        /// This contains details about the lines and stops that are impacted by the described alert.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("affected")]
        public Affected Affected { get; set; }

        /// <summary>
        /// This is the descriptive alert content. It may contain HTML tags and/or HTML entities.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// This is a unique identifier for this particular service alert.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This value indicates how important the service alert is. A value of `high` or `veryHigh` likely indicates that
        /// <br/>the alert will correspond to an event that impacts the ability to travel for relevant users, while `low` or `veryLow`
        /// <br/>might be more of an informational message.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("priority")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AdditionalInfoResponseMessagePriority? Priority { get; set; }

        /// <summary>
        /// This element contains a additional information about the alert.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("properties")]
        public Properties Properties { get; set; }

        /// <summary>
        /// This is short summary that can be used as a heading for the alert content. It may contain HTML tags and/or HTML entities.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("subtitle")]
        public string Subtitle { get; set; }

        /// <summary>
        /// This contains a number of timestamps that describe when the alert was created, and when the described alert actually
        /// <br/>takes place and/or is relevant.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("timestamps")]
        public AdditionalInfoResponseTimestamps Timestamps { get; set; }

        /// <summary>
        /// This indicates the category of the service alert. For example, if this value is `stopInfo`, then the alert is
        /// <br/>related to an issue affecting a stop. It is then likely that the affected lines would be those that stop at
        /// <br/>the affected stop.
        /// <br/>
        /// <br/>* `routeInfo`: The alert is related to a specific route
        /// <br/>* `stopInfo`: The alert is related to a specific stop
        /// <br/>* `stopBlocking`: This alert is related to a stop closure
        /// <br/>* `lineInfo`: The alert is related to a specific journey
        /// <br/>* `bannerInfo`: The alert of high importance and potentially has a network-wide impact.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public AdditionalInfoResponseMessageType? Type { get; set; }

        /// <summary>
        /// This field contains a URL that contains additional information about the alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("url")]
        public string Url { get; set; }

        /// <summary>
        /// This field contains a title that can be used when displaying the `infoLinkURL` URL.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("urlText")]
        public string UrlText { get; set; }

        /// <summary>
        /// This number indicates the version of this alert. Initially when it is created it has version `1`, but if it is then
        /// <br/>updated it will have a new `lastModification` value and the version will now be `2`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public int? Version { get; set; }

    }

    /// <summary>
    /// This element describes timestamps for a service alert.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class AdditionalInfoResponseTimestamps
    {

        /// <summary>
        /// This describes when the alert should published. Note that this is used as guidance only and your own
        /// <br/>needs may vary.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("availability")]
        public Availability Availability { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates when the alert was created.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("creation")]
        public string Creation { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates when the alert was last modified.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lastModification")]
        public string LastModification { get; set; }

        /// <summary>
        /// This describes when the incident is actually occurring.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("validity")]
        public System.Collections.Generic.ICollection<Validity> Validity { get; set; }

    }

    /// <summary>
    /// This element contains information about an error that may have occurred when handling an API request.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ApiErrorResponse
    {

        /// <summary>
        /// Describes the error that went wrong
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("message")]
        public string Message { get; set; }

        /// <summary>
        /// If the error was related to the API version, this element contains version information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("versions")]
        public Versions Versions { get; set; }

    }

    /// <summary>
    /// This is the response data returned when performing an `coord` request.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CoordRequestResponse
    {

        /// <summary>
        /// If an error has occurred, this element contains information about the error.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public ApiErrorResponse Error { get; set; }

        /// <summary>
        /// This contains a list of all of the stops, reload points and places of interest found based on the given request.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("locations")]
        public System.Collections.Generic.ICollection<CoordRequestResponseLocation> Locations { get; set; }

        /// <summary>
        /// The version of the API that provided the response. Note that if this value is different to above, then the returned data may be
        /// <br/>different than expected. You can set the expected version using the `version` request parameter.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public string Version { get; set; }

    }

    /// <summary>
    /// Describes a single point that is returned based on the given request.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class CoordRequestResponseLocation
    {

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// This is the short version of the location name, which does not include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// This is a unique ID for the returned location. Certain types of ID can be used for subsequent searches performed with `stop_finder`,
        /// <br/>or can be used as the origin or destination in an `trip` request. The format of a location ID differs greatly, depending
        /// <br/>on the type of location it is.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Contains a human-readable title for the location.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// If available, contains information about this location's parent location. For example, if the
        /// <br/>stop has a type of `platform`, then this field may contain information about the station in which
        /// <br/>the platform is located.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// This data contains additional information about each location, mainly related to how
        /// <br/>it can be categorised or displayed on a map.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("properties")]
        public Properties2 Properties { get; set; }

        /// <summary>
        /// This specifies the type of the returned item. If you search with a type of `GIS_POINT`,
        /// <br/>a returned item has a type of `gisPoint`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public CoordRequestResponseLocationType? Type { get; set; }

    }

    /// <summary>
    /// This is the response data returned when performing an `departure_mon` request.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DepartureMonitorResponse
    {

        /// <summary>
        /// If an error has occurred, this element contains information about the error.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public ApiErrorResponse Error { get; set; }

        /// <summary>
        /// Contains a list of stops that were matched based on the supplied `type_dm` and `name_dm` request values. There must be exactly
        /// <br/>one location present for the `stopEvents` response data to be populated. Additionally, the `mode` request value must be set
        /// <br/>to `direct`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("locations")]
        public System.Collections.Generic.ICollection<StopFinderLocation> Locations { get; set; }

        /// <summary>
        /// Contains a list of departures/arrivals for the stop included in the `location` property of the response.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stopEvents")]
        public System.Collections.Generic.ICollection<DepartureMonitorResponseStopEvent> StopEvents { get; set; }

        /// <summary>
        /// The version of the API that provided the response. Note that if this value is different to above, then the returned data may be
        /// <br/>different than expected. You can set the expected version using the `version` request parameter.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public string Version { get; set; }

    }

    /// <summary>
    /// Corresponds to a single departure or arrival for the given stop.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class DepartureMonitorResponseStopEvent
    {

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("departureTimePlanned")]
        public string DepartureTimePlanned { get; set; }

        /// <summary>
        /// Contains a number of service alert messages relating to this stop event.
        /// <br/>Information returned here is also available using the `add_info` API endpoint.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("infos")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStopInfo> Infos { get; set; }

        /// <summary>
        /// This element contains a single location associated with this stop time.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("location")]
        public StopFinderLocation Location { get; set; }

        /// <summary>
        /// This element describes the mode of transportation and/or the specific route or trip
        /// <br/>used for this stop time.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transportation")]
        public TripTransportation Transportation { get; set; }

    }

    /// <summary>
    /// This element contains information about a HTTP error that occurred.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class HttpErrorResponse
    {

        /// <summary>
        /// The date and time that the error occurred.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("ErrorDateTime")]
        public string ErrorDateTime { get; set; }

        /// <summary>
        /// A detailed message about the error.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("Message")]
        public string Message { get; set; }

        /// <summary>
        /// The HTTP request method used for the current request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("RequestedMethod")]
        public string RequestedMethod { get; set; }

        /// <summary>
        /// The URL for the current request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("RequestedUrl")]
        public string RequestedUrl { get; set; }

        /// <summary>
        /// A unique identifier for the current request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("TransactionId")]
        public string TransactionId { get; set; }

    }

    /// <summary>
    /// Describes a parent location. Locations are hierarchical, mean a location has a parent, and
    /// <br/>a location may have any number of child locations. A parent location is often included with locations,
    /// <br/>which can help traverse the location tree.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class ParentLocation
    {

        /// <summary>
        /// This is the short version of the location name, which does not include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// This is a unique ID for the returned location. Certain types of ID can be used for subsequent searches performed with `stop_finder`,
        /// <br/>or can be used as the origin or destination in an `trip` request. The format of a location ID differs greatly, depending
        /// <br/>on the type of location it is.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the long version of the location name, which may include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// In some cases, a parent location will also contain its parent (in other words, the grandparent of the initial location)
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// This is the type of location being returned. It may represent a stop or platform that a public transport service physically
        /// <br/>stops at for passenger boarding, or it may represent somebody's house.
        /// <br/>A value of `unknown` likely indicates bad data coming from the server. If a location is returned with this type, you can safely ignore it.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public ParentLocationType? Type { get; set; }

    }

    /// <summary>
    /// This element contains additional properties about the route.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class RouteProduct
    {

        /// <summary>
        /// This field indicates the type of the route, using the same values
        /// <br/>as elsewhere in this API.
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>* `99`: Walking
        /// <br/>* `100`: Walking (Footpath)
        /// <br/>* `101`: Bicycle
        /// <br/>* `102`: Take Bicycle On Public Transport
        /// <br/>* `103`: Kiss &amp; Ride
        /// <br/>* `104`: Park &amp; Ride
        /// <br/>* `105`: Taxi
        /// <br/>* `106`: Car
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("class")]
        public int? Class { get; set; }

        /// <summary>
        /// This field is used by to determine which icon to use when displaying
        /// <br/>this affected route. It will typically match up with the `class` value.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("iconId")]
        public int? IconId { get; set; }

        /// <summary>
        /// Name of the product
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

    }

    /// <summary>
    /// An assigned stop is a location that public transport stops at. Locations / places of interest that aren't stops may have one
    /// <br/>or more stops "assigned" to it as being "the stop(s) you would use if you were in this location".
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StopFinderAssignedStop
    {

        /// <summary>
        /// This is the mode of transport that is used to connect to this stop. The following values are available:
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>* `97`: Remain On-Board
        /// <br/>* `99`: Walking
        /// <br/>* `100`: Walking (Footpath)
        /// <br/>* `101`: Bicycle
        /// <br/>* `102`: Take Bicycle On Public Transport
        /// <br/>* `103`: Kiss &amp; Ride
        /// <br/>* `104`: Park &amp; Ride
        /// <br/>* `105`: Taxi
        /// <br/>* `106`: Car
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("connectingMode")]
        public int? ConnectingMode { get; set; }

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// This is the short version of the location name, which does not include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// This is the distance in metres to this stop from the location to which it is assigned.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distance")]
        public int? Distance { get; set; }

        /// <summary>
        /// This is the number of minutes it would take to reach this stop from the location to which it is assigned.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("duration")]
        public int? Duration { get; set; }

        /// <summary>
        /// This is a unique ID for the returned location. Certain types of ID can be used for subsequent searches performed with `stop_finder`,
        /// <br/>or can be used as the origin or destination in an `trip` request. The format of a location ID differs greatly, depending
        /// <br/>on the type of location it is.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is included only if the `type` value is set to `stop`. Contains a list of modes of transport
        /// <br/>that service this stop. This can be useful for showing relevant wayfinding icons when presenting users
        /// <br/>with a list of matching stops to choose from.
        /// <br/>
        /// <br/>The following values may be present:
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("modes")]
        public System.Collections.Generic.ICollection<int> Modes { get; set; }

        /// <summary>
        /// This is the long version of the location name, which may include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// If available, contains information about this location's parent location. For example, if the
        /// <br/>stop has a type of `platform`, then this field may contain information about the station in which
        /// <br/>the platform is located.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// A value of `unknown` likely indicates bad data. If a location is returned with this type, you can safely ignore it.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public StopFinderAssignedStopType? Type { get; set; }

    }

    /// <summary>
    /// This element describes a single location that is returned in an `stop_finder` request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StopFinderLocation
    {

        /// <summary>
        /// This is a list of stops that are assigned to this location. This means if you're in the current location and want to catch
        /// <br/>public transport, these assigned stops are directly available to you.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("assignedStops")]
        public System.Collections.Generic.ICollection<StopFinderAssignedStop> AssignedStops { get; set; }

        /// <summary>
        /// This is the number of the property, included only if the `type` value is set to `singlehouse`. Note that it is a string, as it may include non-numeric characters.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("buildingNumber")]
        public string BuildingNumber { get; set; }

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// This is the short version of the location name, which does not include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// This is a unique ID for the returned location. Certain types of ID can be used for subsequent searches performed with `stop_finder`,
        /// <br/>or can be used as the origin or destination in an `trip` request. The format of a location ID differs greatly, depending
        /// <br/>on the type of location it is.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Indicates whether or not this is the best match out of all the returned locations.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isBest")]
        public bool? IsBest { get; set; }

        /// <summary>
        /// This determines whether the id property is a global stop id or not
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isGlobalId")]
        public bool? IsGlobalId { get; set; }

        /// <summary>
        /// This value indicates how well the returned stop matches the search query. A higher number indicates a better match.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("matchQuality")]
        public int? MatchQuality { get; set; }

        /// <summary>
        /// This is included only if the `type` value is set to `stop`. Contains a list of modes of transport
        /// <br/>that service this stop. This can be useful for showing relevant wayfinding icons when presenting users
        /// <br/>with a list of matching stops to choose from.
        /// <br/>
        /// <br/>The following values may be present:
        /// <br/>
        /// <br/>* `1`: Train
        /// <br/>* `2`: Metro
        /// <br/>* `4`: Light Rail
        /// <br/>* `5`: Bus
        /// <br/>* `7`: Coach
        /// <br/>* `9`: Ferry
        /// <br/>* `11`: School Bus
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("modes")]
        public System.Collections.Generic.ICollection<int> Modes { get; set; }

        /// <summary>
        /// This is the long version of the location name, which may include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// If available, contains information about this location's parent location. For example, if the
        /// <br/>stop has a type of `platform`, then this field may contain information about the station in which
        /// <br/>the platform is located.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// This is included only if the `type` value is set to `street` or `singlehouse`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("streetName")]
        public string StreetName { get; set; }

        /// <summary>
        /// This is the type of location being returned. It may represent a stop or platform that a public transport service physically
        /// <br/>stops at for passenger boarding, or it may represent somebody's house.
        /// <br/>A value of `unknown` likely indicates bad data coming from the server. If a location is returned with this type, you can safely ignore it.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public StopFinderLocationType? Type { get; set; }

    }

    /// <summary>
    /// This element contains the response for an `stop_finder` request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class StopFinderResponse
    {

        /// <summary>
        /// If an error has occurred, this element contains information about the error.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public ApiErrorResponse Error { get; set; }

        /// <summary>
        /// An array of all locations that were found using the specified search input. To display the results in a way that makes sense to
        /// <br/>the end user, you can sort this list by `matchQuality`. Alternatively, you can group the results by their type and/or sort them
        /// <br/>alphabetically.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("locations")]
        public System.Collections.Generic.ICollection<StopFinderLocation> Locations { get; set; }

        /// <summary>
        /// The version of the API that provided the response. Note that if this value is different to above, then the returned data may be
        /// <br/>different than expected. You can set the expected version using the `version` request parameter.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public string Version { get; set; }

    }

    /// <summary>
    /// This element contains the response from an `trip` request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponse
    {

        /// <summary>
        /// If an error has occurred, this element contains information about the error.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public ApiErrorResponse Error { get; set; }

        /// <summary>
        /// Contains zero or more journeys found based on the input parameters.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("journeys")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourney> Journeys { get; set; }

        /// <summary>
        /// Includes system messages that may be relevant to this particular request.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("systemMessages")]
        public SystemMessages SystemMessages { get; set; }

        /// <summary>
        /// The version of the API that provided the response. Note that if this value is different to above, then the returned data may be
        /// <br/>different than expected. You can set the expected version using the `version` request parameter.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public string Version { get; set; }

    }

    /// <summary>
    /// This element describes a single journey returned by `trip`
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourney
    {

        /// <summary>
        /// XXX
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isAdditional")]
        public bool? IsAdditional { get; set; }

        /// <summary>
        /// This element contains one or more legs that constitute the trip.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("legs")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLeg> Legs { get; set; }

        /// <summary>
        /// XXX
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("rating")]
        public int? Rating { get; set; }

    }

    /// <summary>
    /// Not currently used.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyFareZone
    {

        /// <summary>
        /// Not currently used.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fromLeg")]
        public int? FromLeg { get; set; }

        /// <summary>
        /// Not currently used.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("net")]
        public string Net { get; set; }

        /// <summary>
        /// Not currently used.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("neutralZone")]
        public string NeutralZone { get; set; }

        /// <summary>
        /// Not currently used.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("toLeg")]
        public int? ToLeg { get; set; }

    }

    /// <summary>
    /// This element describes a single leg of a journey. A journey is made up of one or more legs.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLeg
    {

        /// <summary>
        /// This elements contains a list of coordinates that this journey leg follows. A line between
        /// <br/>can be plotted between these coordinates in order when representing the journey on a map
        /// <br/>in order to show where the vehicle travels (or for a walking leg, the path to be walked).
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coords")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<double>> Coords { get; set; }

        /// <summary>
        /// This is the finishing location of the leg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination")]
        public TripRequestResponseJourneyLegStop Destination { get; set; }

        /// <summary>
        /// The approximate distance in metres travelled to complete this journey leg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distance")]
        public int? Distance { get; set; }

        /// <summary>
        /// The approximate amount of time in seconds required to complete this journey leg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("duration")]
        public int? Duration { get; set; }

        /// <summary>
        /// If the leg corresponds to a walking leg, this element contains walking directions.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("footPathInfo")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStopFootpathInfo> FootPathInfo { get; set; }

        /// <summary>
        /// Contains a number of additional informational messages that may be useful for travellers.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("hints")]
        public System.Collections.Generic.ICollection<Hints> Hints { get; set; }

        /// <summary>
        /// Contains a number of service alert messages relating to this journey leg.
        /// <br/>Information returned here is also available using the `add_info` API endpoint.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("infos")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStopInfo> Infos { get; set; }

        /// <summary>
        /// Contains information for how to interchange between the end of one leg to the next journey leg.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("interchange")]
        public TripRequestResponseJourneyLegInterchange Interchange { get; set; }

        /// <summary>
        /// This indicates whether or not real-time data has been used to calculate the departure/arrival timestamps
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isRealtimeControlled")]
        public bool? IsRealtimeControlled { get; set; }

        /// <summary>
        /// This is the starting location of the leg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("origin")]
        public TripRequestResponseJourneyLegStop Origin { get; set; }

        /// <summary>
        /// Contains walking information for completing this journey leg.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("pathDescriptions")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegPathDescription> PathDescriptions { get; set; }

        /// <summary>
        /// Contains additional information about this journey leg, such as wheelchair accessibility information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("properties")]
        public Properties3 Properties { get; set; }

        /// <summary>
        /// This is a list of all stops that are made for this leg. It is sorted in order of its
        /// <br/>stopping sequence. If the leg is a walking leg between two stops, then this will contain
        /// <br/>these two stops in order.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stopSequence")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStop> StopSequence { get; set; }

        /// <summary>
        /// This element contains information about the mode of transport and/or route
        /// <br/>used to complete this journey leg.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("transportation")]
        public TripTransportation Transportation { get; set; }

    }

    /// <summary>
    /// This object describes walking directions for interchanging between two consecutive legs. This
    /// <br/>occurs in the case when there's only a small distance between two transit legs, not enough
    /// <br/>to constitute a standalone walking leg.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegInterchange
    {

        /// <summary>
        /// This is a list of coordinates that makes up the path of the interchange.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coords")]
        public System.Collections.Generic.ICollection<System.Collections.Generic.ICollection<double>> Coords { get; set; }

        /// <summary>
        /// This is a description of the interchange.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("desc")]
        public string Desc { get; set; }

        /// <summary>
        /// This indicates the mode of travel for the interchange. Both `99` and `100` indicate walking.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public TripRequestResponseJourneyLegInterchangeType? Type { get; set; }

    }

    /// <summary>
    /// Contains a single instruction for completing a walking leg associated with a journey leg.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegPathDescription
    {

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude. This is the
        /// <br/>location where the instruction occurs.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// This is the cumulative distance travelled in metres at the point of this step.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cumDistance")]
        public int? CumDistance { get; set; }

        /// <summary>
        /// This is the cumulative duration in seconds at the point of this step.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("cumDuration")]
        public int? CumDuration { get; set; }

        /// <summary>
        /// This is the distance travelled in this step in metres.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distance")]
        public int? Distance { get; set; }

        /// <summary>
        /// This is the distance travelled downward in this step in metres
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distanceDown")]
        public int? DistanceDown { get; set; }

        /// <summary>
        /// This is the distance travelled upward in this step in metres
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distanceUp")]
        public int? DistanceUp { get; set; }

        /// <summary>
        /// This is the duration of this step in seconds.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("duration")]
        public int? Duration { get; set; }

        /// <summary>
        /// This field enables you to retrieve multiple coordinates from the `coords` property, starting from this index.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("fromCoordsIndex")]
        public int? FromCoordsIndex { get; set; }

        /// <summary>
        /// Indicates what you have to do (in addition the turn `turnDirection`) to execute this step of the path description.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("manoeuvre")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegPathDescriptionManoeuvre? Manoeuvre { get; set; }

        /// <summary>
        /// This is a specific description of what to do. In some cases, this information is required in addition to the
        /// <br/>other properties provided in this step.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The direction in degrees (0-359) of the skyDirection
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("skyDirection")]
        public int? SkyDirection { get; set; }

        /// <summary>
        /// This field enables you to retrieve multiple coordinates from the `coords` property, ending at this index.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("toCoordsIndex")]
        public int? ToCoordsIndex { get; set; }

        /// <summary>
        /// Indicates the way you need to turn to execute this step of the path description.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("turnDirection")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegPathDescriptionTurnDirection? TurnDirection { get; set; }

    }

    /// <summary>
    /// Contains information about a single stop in the journey leg.
    /// <br/>Typically, the first stop in a journey leg will only include departure time information,
    /// <br/>while the last stop in a journey leg will only include arrival time information. Stops in between
    /// <br/>will include both arrival and departure time information.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStop
    {

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the estimated arrival time. If real-time
        /// <br/>information is available then this timestamp is the real-time estimate, otherwise it is the same as the
        /// <br/>value in `arrivalTimePlanned`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("arrivalTimeEstimated")]
        public string ArrivalTimeEstimated { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the planned arrival time. This is
        /// <br/>the original scheduled time.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("arrivalTimePlanned")]
        public string ArrivalTimePlanned { get; set; }

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the estimated departure time. If real-time
        /// <br/>information is available then this timestamp is the real-time estimate, otherwise it is the same as the
        /// <br/>value in `departureTimePlanned`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("departureTimeEstimated")]
        public string DepartureTimeEstimated { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the planned departure time. This is
        /// <br/>the original scheduled time.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("departureTimePlanned")]
        public string DepartureTimePlanned { get; set; }

        /// <summary>
        /// This is the short version of the location name, which does not include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// This is a unique ID for the returned location. Certain types of ID can be used for subsequent searches performed with `stop_finder`,
        /// <br/>or can be used as the origin or destination in an `trip` request. The format of a location ID differs greatly, depending
        /// <br/>on the type of location it is.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the long version of the location name, which may include the suburb or other information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// If available, contains information about this location's parent location. For example, if the
        /// <br/>stop has a type of `platform`, then this field may contain information about the station in which
        /// <br/>the platform is located.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("parent")]
        public ParentLocation Parent { get; set; }

        /// <summary>
        /// Contains additional information about this stop, such as wheelchair accessibility information.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("properties")]
        public Properties4 Properties { get; set; }

        /// <summary>
        /// This is the type of location being returned. It will typically represent a specific stop or platform.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegStopType? Type { get; set; }

    }

    /// <summary>
    /// Describes a single download available for this journey stop.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStopDownload
    {

        /// <summary>
        /// This indicates what type of download this is. For example, `RM` refers to Route Map.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

        /// <summary>
        /// This is the URL for the download.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("url")]
        public string Url { get; set; }

    }

    /// <summary>
    /// Contains walking directions for a walking leg.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStopFootpathInfo
    {

        /// <summary>
        /// This is approximately how long in seconds the walking instructions contained in this element take to perform.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("duration")]
        public int? Duration { get; set; }

        /// <summary>
        /// This describes the specific instructions for the walking leg.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("footPathElem")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStopFootpathInfoFootpathElem> FootPathElem { get; set; }

        /// <summary>
        /// This indicates where in the leg the walking part of this legs occurs, since for some legs this
        /// <br/>is included with transportation on a vehicle.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("position")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegStopFootpathInfoPosition? Position { get; set; }

    }

    /// <summary>
    /// The element describes a single walking instruction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStopFootpathInfoFootpathElem
    {

        /// <summary>
        /// Contains additional information about this instruction, but is generally unused.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// Indicates the starting location for this leg, in terms of locations in the system
        /// <br/>such as stops or places of interest. Typically, since these instructions indicate
        /// <br/>how to travel within a stop or station, the `origin` and `destination` will both
        /// <br/>reference the same stop, but the coordinate will be specific to this instruction.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination")]
        public TripRequestResponseJourneyLegStopFootpathInfoFootpathElemLocation Destination { get; set; }

        /// <summary>
        /// Indicates the direction of travel for this instruction. Generally a ramp, escalator
        /// <br/>or stairs will go `UP` or `DOWN` to a different floor. This value will be `LEVEL` when
        /// <br/>the `type` field is also `LEVEL`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("level")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegStopFootpathInfoFootpathElemLevel? Level { get; set; }

        /// <summary>
        /// Indicates the floor number the instruction is starting from. If the `type` is `LEVEL`,
        /// <br/>then the `levelFrom` and `levelTo` values should be the same.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("levelFrom")]
        public int? LevelFrom { get; set; }

        /// <summary>
        /// Indicates the floor number the instruction ends of. If the `type` is `LEVEL`,
        /// <br/>then the `levelFrom` and `levelTo` values should be the same.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("levelTo")]
        public int? LevelTo { get; set; }

        /// <summary>
        /// Indicates the starting location for this leg, in terms of locations in the system
        /// <br/>such as stops or places of interest. Typically, since these instructions indicate
        /// <br/>how to travel within a stop or station, the `origin` and `destination` will both
        /// <br/>reference the same stop, but the coordinate will be specific to this instruction.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("origin")]
        public TripRequestResponseJourneyLegStopFootpathInfoFootpathElemLocation Origin { get; set; }

        /// <summary>
        /// This indicates the type of "terrain" for this instruction. `LEVEL` indicates a normal
        /// <br/>flat surface.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegStopFootpathInfoFootpathElemType? Type { get; set; }

    }

    /// <summary>
    /// This element describes a starting or finishing point for a walking instruction.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStopFootpathInfoFootpathElemLocation
    {

        /// <summary>
        /// This is an internal value used to group stops together.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("area")]
        public int? Area { get; set; }

        /// <summary>
        /// This is an identifier for this particular instruction / location, based on its location.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("georef")]
        public string Georef { get; set; }

        /// <summary>
        /// This includes information about the location in which this instruction takes place.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("location")]
        public Location Location { get; set; }

        /// <summary>
        /// If available, this is a platform number that relates to this instruction. It defaults to `0` if
        /// <br/>there is no such information available.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("platform")]
        public int? Platform { get; set; }

    }

    /// <summary>
    /// This element describes a single information message that may be associated with a journey leg.
    /// <br/>The data in this is similar to that from `add_info`, but is presented differently.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseJourneyLegStopInfo
    {

        /// <summary>
        /// This is the descriptive alert content. It may contain HTML tags and/or HTML entities.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("content")]
        public string Content { get; set; }

        /// <summary>
        /// This is a unique identifier for this particular service alert. Note that this same ID is used in
        /// <br/>`add_info` for the same alert.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This value indicates how important the service alert is. A value of `high` or `veryHigh` likely indicates that
        /// <br/>the alert will correspond to an event that impacts the ability to travel for relevant users, while `low` or `veryLow`
        /// <br/>might be more of an informational message.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("priority")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public TripRequestResponseJourneyLegStopInfoPriority? Priority { get; set; }

        /// <summary>
        /// This is short summary that can be used as a heading for the alert content. It may contain HTML tags and/or HTML entities.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("subtitle")]
        public string Subtitle { get; set; }

        /// <summary>
        /// This contains a number of timestamps that describe when the alert was created, and when the described alert actually
        /// <br/>takes place and/or is relevant.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("timestamps")]
        public AdditionalInfoResponseTimestamps Timestamps { get; set; }

        /// <summary>
        /// This field contains a URL that contains additional information about the alert. This value is equivalent to
        /// <br/>the `infoLinkURL` value in `add_info`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("url")]
        public string Url { get; set; }

        /// <summary>
        /// This field contains a title that can be used when displaying the `url` URL. This value is equivalent to
        /// <br/>the `infoLinkText` value in `add_info`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("urlText")]
        public string UrlText { get; set; }

        /// <summary>
        /// This number indicates the version of this alert. Initially when it is created it has version `1`, but if it is then
        /// <br/>updated it will have a new `lastModification` value and the version will now be `2`.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("version")]
        public int? Version { get; set; }

    }

    /// <summary>
    /// This element describes a single message that may be included with an `trip` request.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripRequestResponseMessage
    {

        /// <summary>
        /// This is an error/warning code for the message. Note that the same code may be returned
        /// <br/>with a different meaning, depending on the context. The following error codes are possible:
        /// <br/>
        /// <br/>* `-1000` (`PLACE_INVALID`) - Invalid locality input
        /// <br/>* `-1001` (`PLACE_WITHOUT_STOPS`) - Verified locality does not have stops
        /// <br/>* `-1010` (`PLACE_UNKNOWN_POOL`) - Locality not in locality tree
        /// <br/>* `-1020` (`PLACE_ALPHA_INVALID`) - Invalid alpha list
        /// <br/>
        /// <br/>* `-2000` (`STOP_INVALID`) - Invalid stop input
        /// <br/>* `-2001` (`STOP_PLACE_ID_INVALID`) - Stop number not in locality
        /// <br/>
        /// <br/>* `-3000` (`ADDRESS_INVALID`) - Invalid address input
        /// <br/>* `-3001` (`ADDRESS_PLACE_WITHOUT_ADDR`) - Locality does not have any addresses
        /// <br/>
        /// <br/>* `-1000` (`IT_COORD_UNKNOWN`) - Transferred coordinate not supported (incorrect coordinate system)
        /// <br/>* `-1001` (`IT_COORD_OUT_OF_REGION`) - Transferred coordinates not supported (outside of region)
        /// <br/>* `-1002` (`IT_COORD_FORMAT_UNKNOWN`) - Transferred coordinate is ok, but the format does not match the value
        /// <br/>* `-200` (`IT_GEOREF_UNKNOWN`) - Invalid georeference
        /// <br/>* `-201` (`IT_GEOREF_OUT_OF_REGION`) - Invalid georeference section &lt; 0 or &gt; length of route section
        /// <br/>* `-300` (`IT_NO_START`) - No origin entered
        /// <br/>* `-301` (`IT_NO_DESTINATION`) - No destination entered
        /// <br/>* `-302` (`IT_NO_CONNECTION`) - No journey found
        /// <br/>* `-303` (`IT_NO_TRANSITIONS`) - No transition point
        /// <br/>
        /// <br/>* `-3000` (`IT_ADDRESS_INVALID`) - Address invalid
        /// <br/>* `-3001` (`IT_ADDRESS_PLACE_WITHOUT_ADDR`) - Locality does not have any addresses
        /// <br/>* `-3002` (`IT_ADDRESS_EMPTY`) - Empty address input
        /// <br/>
        /// <br/>* `-5000` (`IT_LOCATOR_INVALID`) - Input locality is invalid
        /// <br/>* `-5001` (`IT_LOCATOR_INVALID_POOL`) - Input locality not available in locality tree
        /// <br/>* `-5002` (`IT_LOCATOR_BULK_POSTCODE`) - Bulk postcode, postcode with addresses
        /// <br/>
        /// <br/>* `-4000` (`IT_STREET_INVALID`) - Input street is invalid
        /// <br/>* `-4001` (`IT_STREE_PLACE_WITHOUT_ADDR`) - Locality does not have any streets
        /// <br/>
        /// <br/>* `-8010` (`ANY_UNIQUE`) - Any input uniquely verified
        /// <br/>* `-8011` (`ANY_LIST`) - Any list verified
        /// <br/>* `-8012` (`ANY_INVALID`) - Any input invalid
        /// <br/>* `-8013` (`ANY_PLACE_WITHOUT_MATCHES`) - Any location found, but cannot be verified
        /// <br/>* `-8014` (`ANY_TOO_MANY_MATCHES`) - Any input has too many matches
        /// <br/>* `-8020` (`ANY_MATCH_NONE`) - No matches
        /// <br/>* `-8031` (`ANY_MATCH`) - Matches (e.g. buildings) found for a street
        /// <br/>* `-8032` (`ANY_NO_MATCH`) - No matches found (e.g. buildings) for a street
        /// <br/>
        /// <br/>* `-4000` (`NO_CONNECTION`) - No journey found for the time entered
        /// <br/>* `-4001` (`DATE_INVALID`) - Date not possible in the current timetable period
        /// <br/>* `-4002` (`NO_ORIGIN`) - No origin verified
        /// <br/>* `-4003` (`NO_DESTINATION`) - No destination verified
        /// <br/>* `-4004` (`ORIGIN_UNKNOWN`) - Origin exists, but cannot be identified
        /// <br/>* `-4005` (`DESTINATION_UNKNOWN`) - Destination exists, but cannot be identified
        /// <br/>* `-4006` (`JUST_WALK`) - Only a walk has been found
        /// <br/>* `-4007` (`ORIGIN_EQUI_DEST`) - Origin and destination are identical
        /// <br/>* `-4008` (`VIA_UNKNOWN`) - Unknown via-point
        /// <br/>* `-4009` (`TIMESPAN_INVALID`) - Time interval is invalid
        /// <br/>* `-4010` (`VIA_NOINTERCHANGE`) - Via stop point is not an interchange stop
        /// <br/>* `-4011` (`VIA_INVALID`) - Invalid via input
        /// <br/>* `+4011` (`TRIPSTATUS_ALREADYFOUND`) - Moved journey already exists
        /// <br/>* `-4012` (`ORIGIN_OUTOFPERMITTEDAREA`) - Origin outside the valid zone (e.g. fare zone)
        /// <br/>* `-4013` (`DESTINATION_OUTOFPERMITTEDAREA`) - Destination outside the valid zone (e.g. fare zone)
        /// <br/>* `-4014` (`VIA_OUTOFPERMITTEDAREA`) - Via outside the valid zone (e.g. fare zone)
        /// <br/>* `-4020` (`NO_TRANSITION`) - No transition point found
        /// <br/>* `-4030` (`NO_DEPARTURE`) - No departures found
        /// <br/>* `-4040` (`NO_ARRIVAL`) - No arrivals found
        /// <br/>* `-4050` (`NO_SERVINGLINES`) - No services found at this stop
        /// <br/>* `-4060` (`NO_MATCHINGOPERATORS`) - No matching operators
        /// <br/>
        /// <br/>* `-4100` (`NO_CONNECTION_BECAUSE_OF_RULE`) - No journey because of a rule
        /// <br/>* `-4101` (`RULE_CHANGED_OPTIONS`) - Rule changed the options
        /// <br/>* `-4102` (`RULE_CHANGED_USEONLY`) - Rule chagned the permitted vehicles
        /// <br/>* `-4103` (`RECOMPUTE_BECAUSE_OF_RULE`) - Journey has been recalculated due to a rule with different parameters
        /// <br/>* `-4104` (`RULE_CHANGED_WITHOUTVIA`) - Rule removed the via point
        /// <br/>* `-4300` (`NO_CONNECTION_BECAUSE_OF_PREFERTOEXCLUDE_SETTINGS`) - Invalid prefer-to-exclude parameter
        /// <br/>* `-4301` (`NO_CONNECTION_BECAUSE_OF_PREFERTOINCLUDE_SETTINGS`) - Invalid prefer-to-include parameter
        /// <br/>* `-4302` (`NO_CONNECTION_BECAUSE_OF_MIXEDSETTING_SETTINGS`) - Invalid mixing of prefer-to-exclude/include parameters
        /// <br/>* `-4303` (`NO_CONNECTION_BECAUSE_OF_WALKING_SETTINGS`) - Invalid footpath parameter
        /// <br/>* `-9999` (`TRIP_CANCELLED`) - Trip has been cancelled
        /// <br/>* `-10015` (`ERROR_ITROUTER_NO_IT_CONN`) - No journey found
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("code")]
        public int? Code { get; set; }

        /// <summary>
        /// This is the error summary for the given message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("error")]
        public string Error { get; set; }

        /// <summary>
        /// Indicates the server module that provided this system message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("module")]
        public string Module { get; set; }

        /// <summary>
        /// Indicates the type of system message.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

    }

    /// <summary>
    /// This element describes a route, including information about its route number, usual destination,
    /// <br/>route type and operator.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripTransportation
    {

        /// <summary>
        /// Contains a description of this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("description")]
        public string Description { get; set; }

        /// <summary>
        /// This element contains information about where vehicles on this route terminate.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("destination")]
        public Destination2 Destination { get; set; }

        /// <summary>
        /// Contains a very short name for the route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("disassembledName")]
        public string DisassembledName { get; set; }

        /// <summary>
        /// Contains an ID for the icon that can be used for this route. Different values here are
        /// <br/>used to differentiate differents types of the same route type. For example, private ferries
        /// <br/>have a different wayfinding icon to ferries operated by Sydney Ferries.
        /// <br/>
        /// <br/>* `1`: Sydney Trains (product class `1`)
        /// <br/>* `2`: Intercity Trains (product class `1`)
        /// <br/>* `3`: Regional Trains (product class `1`)
        /// <br/>* `19`: Temporary Trains (product class `1`)
        /// <br/>
        /// <br/>* `24`: Sydney Metro (product class `2`)
        /// <br/>
        /// <br/>* `13`: Sydney Light Rail (product class `4`)
        /// <br/>* `20`: Temporary Light Rail (product class `4`)
        /// <br/>* `21`: Newcastle Light Rail (product class `4`)
        /// <br/>
        /// <br/>* `4`: Blue Mountains Buses (product class `5`)
        /// <br/>* `5`: Sydney Buses (product class `5`)
        /// <br/>* `6`: Central Coast Buses (product class `5`)
        /// <br/>* `14`: Temporary Buses (product class `5`)
        /// <br/>* `15`: Hunter Buses (product class `5`)
        /// <br/>* `23`: On Demand (product class `5`)
        /// <br/>* `31`: Central West and Orana (product class `5`)
        /// <br/>* `32`: Far West (product class `5`)
        /// <br/>* `33`: New England North West (product class `5`)
        /// <br/>* `34`: Newcastle and Hunter (product class `5`)
        /// <br/>* `35`: North Coast (product class `5`)
        /// <br/>* `36`: Riverina Murray (product class `5`)
        /// <br/>* `37`: South East and Tablelands (product class `5`)
        /// <br/>* `38`: Sydney and Surrounds (product class `5`)
        /// <br/>
        /// <br/>* `9`: Private Buses (product class `5`)
        /// <br/>* `17`: Private Coaches (product class `5`)
        /// <br/>
        /// <br/>* `7`: Regional Coaches (product class `7`)
        /// <br/>* `22`: Temporary Coaches (product class `7`)
        /// <br/>
        /// <br/>* `10`: Sydney Ferries (product class `9`)
        /// <br/>* `11`: Newcastle Ferries (product class `9`)
        /// <br/>* `12`: Private Ferries (product class `9`)
        /// <br/>* `18`: Temporary Ferries (product class `9`)
        /// <br/>
        /// <br/>* `8`: School Buses (product class `11`)
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("iconId")]
        public int? IconId { get; set; }

        /// <summary>
        /// This is an ID that uniquely identifies this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This contains the full name of the route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Contains a short name for the route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("number")]
        public string Number { get; set; }

        /// <summary>
        /// This element describes the operator of this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("operator")]
        public Operator Operator { get; set; }

        /// <summary>
        /// This element contains additional properties about the route.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("product")]
        public RouteProduct Product { get; set; }

        /// <summary>
        /// Contains additional properties about this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("properties")]
        public Properties5 Properties { get; set; }

    }

    /// <summary>
    /// Used to set the response data type. This documentation only covers responses that use the JSON format.
    /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutputFormat
    {

        [System.Runtime.Serialization.EnumMember(Value = @"rapidJSON")]
        RapidJSON = 0,

    }

    /// <summary>
    /// This parameter allows you to filter the returned items by the modes of transport they affected. Available modes include:
    /// <br/>
    /// <br/>* `1`: Train
    /// <br/>* `2`: Metro
    /// <br/>* `4`: Light Rail
    /// <br/>* `5`: Bus
    /// <br/>* `7`: Coach
    /// <br/>* `9`: Ferry
    /// <br/>* `11`: School Bus
    /// <br/>
    /// <br/>To search for more than one mode, include the parameter multiple times.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FilterMOTType
    {

        _1 = 1,

        _2 = 2,

        _4 = 4,

        _5 = 5,

        _7 = 7,

        _9 = 9,

        _11 = 11,

    }

    /// <summary>
    /// This field can be used so only current alerts are returned, and not historic alerts.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum FilterPublicationStatus
    {

        [System.Runtime.Serialization.EnumMember(Value = @"current")]
        Current = 0,

    }

    /// <summary>
    /// Used to set the response data type. This documentation only covers responses that use the JSON format.
    /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutputFormat2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"rapidJSON")]
        RapidJSON = 0,

    }

    /// <summary>
    /// This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CoordOutputFormat
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EPSG:4326")]
        EPSG4326 = 0,

    }

    /// <summary>
    /// This enables "advanced filter mode" on the server, which is required to enable searching using coordinates.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InclFilter
    {

        _1 = 1,

    }

    /// <summary>
    /// This specifies the type of items to return.
    /// <br/>
    /// <br/>* `GIS_POINT`: GIS points, including Opal resellers (see `inclDrawClasses_1`)
    /// <br/>* `BUS_POINT`: Stops/stations
    /// <br/>* `POI_POINT`: Places of interest
    /// <br/>
    /// <br/>The `_1` suffix is an index for this particular filter. You can specify multiple filters by incrementing the suffix
    /// <br/>for each combination of `type`, `radius` and `inclDrawClasses`. For example, `type_1` means the first filter, `type_2`
    /// <br/>refers to the second, and so on.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type_1
    {

        [System.Runtime.Serialization.EnumMember(Value = @"GIS_POINT")]
        GIS_POINT = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"BUS_POINT")]
        BUS_POINT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"POI_POINT")]
        POI_POINT = 2,

    }

    /// <summary>
    /// This flag changes the list of POIs that are returned. To return Opal resellers, set this value to `74`
    /// <br/>and `type_1` to `GIS_POINT`.The suffix of `_1` indicates this radius value corresponds to the `type_1` value.
    /// <br/>If multiple filters are to be included, the appropriate suffix should be updated accordingly.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum InclDrawClasses_1
    {

        _74 = 74,

    }

    /// <summary>
    /// This field indicates how the returned data is to be used, which in turn impacts whether or not certain locations are returned.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum PoisOnMapMacro
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

    }

    /// <summary>
    /// Used to set the response data type. This documentation only covers responses that use the JSON format.
    /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutputFormat3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"rapidJSON")]
        RapidJSON = 0,

    }

    /// <summary>
    /// This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CoordOutputFormat2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EPSG:4326")]
        EPSG4326 = 0,

    }

    /// <summary>
    /// This allows the departure board to display directly without going through the stop verification process. Use this when the stop is known.
    /// <br/>This relies on the given combination of `type_dm` and `name_dm` returning only a single result, otherwise a list of stops and no departures
    /// <br/>shall be returned.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Mode
    {

        [System.Runtime.Serialization.EnumMember(Value = @"direct")]
        Direct = 0,

    }

    /// <summary>
    /// This specifies the type of results expected based on the search input in `name_dm`. By specifying `any`, locations of all types can be returned.
    /// <br/>Typically, this API call is used for a specific stop, so `stop` should be used along with a stop ID or global stop ID in `name_dm`.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type_dm
    {

        [System.Runtime.Serialization.EnumMember(Value = @"any")]
        Any = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"coord")]
        Coord = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 8,

    }

    /// <summary>
    /// Setting this parameter to `$USEPOINT$` enables you to request departures for a specific platform within a station. If this isn't used,
    /// <br/>then departures for all platforms at the stop specified in `name_dm` are returned.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum NameKey_dm
    {

        [System.Runtime.Serialization.EnumMember(Value = @"$USEPOINT$")]
        _USEPOINT_ = 0,

    }

    /// <summary>
    /// Including this parameter enables a number of options that result in the departure monitor operating in the same way
    /// <br/>as the Transport for NSW Trip Planner web site. It is recommended this is enabled, along with the
    /// <br/>`TfNSWDM` parameter.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DepartureMonitorMacro
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

    }

    /// <summary>
    /// This parameter which means of transport to exclude from the departure monitor. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExcludedMeans
    {

        [System.Runtime.Serialization.EnumMember(Value = @"checkbox")]
        Checkbox = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"2")]
        _2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"4")]
        _4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"5")]
        _5 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"7")]
        _7 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"9")]
        _9 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"11")]
        _11 = 7,

    }

    /// <summary>
    /// Excludes train services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_1
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes metro services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes light rail services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_5
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes coach services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_7
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes ferry services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_9
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes school bus services from the departure monitor.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_11
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Including this parameter enables a number of options that result in the departure monitor operating in the same way as the
    /// <br/>Transport for NSW Trip Planner web site, including enabling real-time data. It is recommended this is enabled,
    /// <br/>along with the `departureMonitorMacro` parameter.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TfNSWDM
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

    }

    /// <summary>
    /// Used to set the response data type. This documentation only covers responses that use the JSON format.
    /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutputFormat4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"rapidJSON")]
        RapidJSON = 0,

    }

    /// <summary>
    /// This specifies the type of results expected in the list of returned stops. By specifying `any`, locations of all types can be returned.
    /// <br/>If you specifically know that you're searching using a coord, specify `coord`. Likewise, if you're using a stop ID or global stop ID as an input, use `stop`
    /// <br/>for more accurate results.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type_sf
    {

        [System.Runtime.Serialization.EnumMember(Value = @"any")]
        Any = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"coord")]
        Coord = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 3,

    }

    /// <summary>
    /// This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CoordOutputFormat3
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EPSG:4326")]
        EPSG4326 = 0,

    }

    /// <summary>
    /// Including this parameter enables a number of options that result in the stop finder operating in the same way as the Transport for NSW Trip Planner web site.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TfNSWSF
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

    }

    /// <summary>
    /// Used to set the response data type. This documentation only covers responses that use the JSON format.
    /// <br/>Setting the `outputFormat` value to `rapidJSON` is required to enable JSON output.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum OutputFormat5
    {

        [System.Runtime.Serialization.EnumMember(Value = @"rapidJSON")]
        RapidJSON = 0,

    }

    /// <summary>
    /// This specifies the format the coordinates are returned in. While other variations are available, the `EPSG:4326` format will return the widely-used format.
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CoordOutputFormat4
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EPSG:4326")]
        EPSG4326 = 0,

    }

    /// <summary>
    /// This value anchors the requested date time. If set to `dep`, then trips *departing after* the specified date/time
    /// <br/>*at the specified location* are included.
    /// <br/>If set to `arr`, then trips *arriving before* the specified time *at its destination stop* are included. Works in conjunctions with the
    /// <br/>`itdDate` and `itdTime` values.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DepArrMacro
    {

        [System.Runtime.Serialization.EnumMember(Value = @"dep")]
        Dep = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"arr")]
        Arr = 1,

    }

    /// <summary>
    /// This is the type of data specified in the `name_origin` field. The origin indicates the starting point when searching for journeys.
    /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_origin`, or to use `coord`
    /// <br/>in this field and a correctly formatted coordinate in `type_origin`.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type_origin
    {

        [System.Runtime.Serialization.EnumMember(Value = @"any")]
        Any = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"coord")]
        Coord = 1,

    }

    /// <summary>
    /// This is the type of data specified in the `name_destination` field. The origin indicates the finishing point when searching for journeys.
    /// <br/>The best way to use the trip planner is to use use `any` for this field then specify a valid location ID in `type_destination`, or to use `coord`
    /// <br/>in this field and a correctly formatted coordinate in `type_destination`.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Type_destination
    {

        [System.Runtime.Serialization.EnumMember(Value = @"any")]
        Any = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"coord")]
        Coord = 1,

    }

    /// <summary>
    /// Including this parameter (regardless of its value) ensures that only wheelchair-accessible options are returned.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Wheelchair
    {

        [System.Runtime.Serialization.EnumMember(Value = @"on")]
        On = 0,

    }

    /// <summary>
    /// This parameter which means of transport to exclude from the trip plan. To exclude one means, select one of the following: `1` = train, `2` = metro, `4` = light rail, `5` = bus, `7` = coach, `9` = ferry, `11` = school bus. `checkbox` allows you to exclude more than one means of transport when used in conjunction with the `exclMOT_&lt;ID&gt;` parameters.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExcludedMeans2
    {

        [System.Runtime.Serialization.EnumMember(Value = @"checkbox")]
        Checkbox = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"2")]
        _2 = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"4")]
        _4 = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"5")]
        _5 = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"7")]
        _7 = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"9")]
        _9 = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"11")]
        _11 = 7,

    }

    /// <summary>
    /// Excludes train services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_12
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes metro services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_22
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes light rail services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_42
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_52
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes coach services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_72
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes ferry services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_92
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Excludes school bus services from the trip plan.  Must be used in conjunction with `excludedMeans=checkbox`
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ExclMOT_112
    {

        [System.Runtime.Serialization.EnumMember(Value = @"1")]
        _1 = 0,

    }

    /// <summary>
    /// Including this parameter enables a number of options that result in this API call operating in the same way as the Transport for NSW Trip Planner web site, including enabling real-time data.
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TfNSWTR
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

    }

    /// <summary>
    /// With the parameter 'bikeProfSpeed' a bike profile name is passed
    /// <br/>
    /// </summary>
    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum BikeProfSpeed
    {

        [System.Runtime.Serialization.EnumMember(Value = @"EASIER")]
        EASIER = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"MODERATE")]
        MODERATE = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"MOST_DIRECT")]
        MOST_DIRECT = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Infos
    {

        /// <summary>
        /// This specifies the list of affected stops and lines. It is an aggregate of each of the affected
        /// <br/>stops and lines listed in the alerts.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("affected")]
        public Affected2 Affected { get; set; }

        /// <summary>
        /// This specifies the list of current service alerts based on the specified filters.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("current")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseMessage> Current { get; set; }

        /// <summary>
        /// This specifies the list of previous service alerts based on the specified filters.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("historic")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseMessage> Historic { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Destination
    {

        /// <summary>
        /// This is the name of the destination.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The type of the location the destination is.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public DestinationType? Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AdditionalInfoResponseAffectedStopType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"gisPoint")]
        GisPoint = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Affected
    {

        /// <summary>
        /// This element contains a list of lines affected by this alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lines")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseAffectedLine> Lines { get; set; }

        /// <summary>
        /// This element contains a list of stops affected by this alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stops")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseAffectedStop> Stops { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AdditionalInfoResponseMessagePriority
    {

        [System.Runtime.Serialization.EnumMember(Value = @"veryLow")]
        VeryLow = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"low")]
        Low = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"normal")]
        Normal = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"high")]
        High = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"veryHigh")]
        VeryHigh = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties
    {

        /// <summary>
        /// This field uniquely identifies which operator or organisation entered the alert into the system.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("providerCode")]
        public string ProviderCode { get; set; }

        /// <summary>
        /// This is a plaintext summary of the alert content, although note that it may contain HTML entities such as &amp;nbsp;.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("smsText")]
        public string SmsText { get; set; }

        /// <summary>
        /// Contains information about who created this alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("source")]
        public Source Source { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum AdditionalInfoResponseMessageType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"routeInfo")]
        RouteInfo = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"stopInfo")]
        StopInfo = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"lineInfo")]
        LineInfo = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"bannerInfo")]
        BannerInfo = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"stopBlocking")]
        StopBlocking = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Availability
    {

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("from")]
        public string From { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("to")]
        public string To { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Validity
    {

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the starting date and time of this date range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("from")]
        public string From { get; set; }

        /// <summary>
        /// A timestamp in `YYYY-MM-DDTHH:MM:SSZ` format that indicates the ending date and time of this date range.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("to")]
        public string To { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Versions
    {

        /// <summary>
        /// The version of the API handling the request
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("controller")]
        public string Controller { get; set; }

        /// <summary>
        /// The maximum version number that can be requested in the `version` request parameter.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("interfaceMax")]
        public string InterfaceMax { get; set; }

        /// <summary>
        /// The minimum version number that can be requested in the `version` request parameter.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("interfaceMin")]
        public string InterfaceMin { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties2
    {

        /// <summary>
        /// This value indicates how the given point can be represented on a map. For example,
        /// <br/>if you have different icons for different categories, use this to determine which icon to use.
        /// <br/>
        /// <br/>* `CityL`
        /// <br/>* `CityM`
        /// <br/>* `CityS`
        /// <br/>* `CityXL`
        /// <br/>* `CityXS`
        /// <br/>* `Generic7`
        /// <br/>* `Generic8`
        /// <br/>* `Generic9`
        /// <br/>* `Generic20`
        /// <br/>* `PoiAirportPublic`
        /// <br/>* `PoiCemetry`
        /// <br/>* `PoiCulture`
        /// <br/>* `PoiGastro`
        /// <br/>* `PoiGeneral`
        /// <br/>* `PoiGovernment`
        /// <br/>* `PoiHistoric`
        /// <br/>* `PoiHotel`
        /// <br/>* `PoiMedicine`
        /// <br/>* `PoiOthers`
        /// <br/>* `PoiPark`
        /// <br/>* `PoiParking`
        /// <br/>* `PoiPublicBuilding`
        /// <br/>* `PoiReligion`
        /// <br/>* `PoiSchool`
        /// <br/>* `PoiSport`
        /// <br/>* `PoiSwimming`
        /// <br/>* `PoiTrafficSpecial`
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("GIS_DRAW_CLASS")]
        public string GIS_DRAW_CLASS { get; set; }

        /// <summary>
        /// This value typically either empty or `POINT`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("GIS_DRAW_CLASS_TYPE")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public Properties2GIS_DRAW_CLASS_TYPE? GIS_DRAW_CLASS_TYPE { get; set; }

        /// <summary>
        /// This data is not used at this time.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("GIS_NIVEAU")]
        public string GIS_NIVEAU { get; set; }

        /// <summary>
        /// This value indicates how the given point can be represented on a map. For example,
        /// <br/>if you have different icons for different categories, use this to determine which icon to use.
        /// <br/>
        /// <br/>* `PoiCemetry`
        /// <br/>* `PoiCulture`
        /// <br/>* `PoiGastro`
        /// <br/>* `PoiGeneral`
        /// <br/>* `PoiGovernment`
        /// <br/>* `PoiHotel`
        /// <br/>* `PoiMedicine`
        /// <br/>* `PoiOthers`
        /// <br/>* `PoiPark`
        /// <br/>* `PoiParking`
        /// <br/>* `PoiPublicBuilding`
        /// <br/>* `PoiReligion`
        /// <br/>* `PoiSchool`
        /// <br/>* `PoiSport`
        /// <br/>* `PoiSwimming`
        /// <br/>* `PoiTrafficSpecial`
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("POI_DRAW_CLASS")]
        public string POI_DRAW_CLASS { get; set; }

        /// <summary>
        /// This value typically either empty or `POINT`.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("POI_DRAW_CLASS_TYPE")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public Properties2POI_DRAW_CLASS_TYPE? POI_DRAW_CLASS_TYPE { get; set; }

        /// <summary>
        /// This field contains a human-readable description of the category to which this
        /// <br/>location belongs. See the description for `POI_HIERARCHY_KEY` for example values that
        /// <br/>correspond to the given keys.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("POI_HIERARCHY_0")]
        public string POI_HIERARCHY_0 { get; set; }

        /// <summary>
        /// This field contains a constant value for the category to which this category belongs.
        /// <br/>
        /// <br/>* `A`: Accommodation
        /// <br/>* `B`: Caravan and Camping
        /// <br/>* `C`: Cemetary
        /// <br/>* `D`: Education
        /// <br/>* `E`: Emergency or Defence
        /// <br/>* `F`: Entertainment
        /// <br/>* `G`: Gardens or Parklands
        /// <br/>* `H`: Golf Clubs
        /// <br/>* `I`: Historical or Religious
        /// <br/>* `K`: Local Government
        /// <br/>* `L`: Medical and Care
        /// <br/>* `O`: Sporting or Recreation
        /// <br/>* `Q`: Tourist Attraction
        /// <br/>* `R`: Transport
        /// <br/>* `S`: Utilities and Facilities
        /// <br/>* `T`: Others
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("POI_HIERARCHY_KEY")]
        public string POI_HIERARCHY_KEY { get; set; }

        /// <summary>
        /// This is the distance in metres to this location from the search location.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("distance")]
        public string Distance { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum CoordRequestResponseLocationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"gisPoint")]
        GisPoint = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum ParentLocationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StopFinderAssignedStopType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum StopFinderLocationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"address")]
        Address = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class SystemMessages
    {

        /// <summary>
        /// Contains zero or more messages.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("responseMessages")]
        public System.Collections.Generic.ICollection<TripRequestResponseMessage> ResponseMessages { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Hints
    {

        /// <summary>
        /// Contains additional information that may be useful for travellers.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("infoText")]
        public string InfoText { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties3
    {

        /// <summary>
        /// XXX
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("DIFFERENT_FARES")]
        public string DIFFERENT_FARES { get; set; }

        /// <summary>
        /// This indicates whether or not the vehicle is wheelchair accessible.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("PlanLowFloorVehicle")]
        public string PlanLowFloorVehicle { get; set; }

        /// <summary>
        /// This indicates whether or not the stop is wheelchair accessible.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("PlanWheelChairAccess")]
        public string PlanWheelChairAccess { get; set; }

        /// <summary>
        /// XXX seen a value of SUPPLEMENT for ferry route
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lineType")]
        public string LineType { get; set; }

        /// <summary>
        /// This value is not currently in use.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("vehicleAccess")]
        public System.Collections.Generic.ICollection<string> VehicleAccess { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegInterchangeType
    {

        _99 = 99,

        _100 = 100,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegPathDescriptionManoeuvre
    {

        [System.Runtime.Serialization.EnumMember(Value = @"LEAVE")]
        LEAVE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"KEEP")]
        KEEP = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"TURN")]
        TURN = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"ENTER")]
        ENTER = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"CONTINUE")]
        CONTINUE = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegPathDescriptionTurnDirection
    {

        [System.Runtime.Serialization.EnumMember(Value = @"UNKNOWN")]
        UNKNOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"STRAIGHT")]
        STRAIGHT = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"RIGHT")]
        RIGHT = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"LEFT")]
        LEFT = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"SLIGHT_RIGHT")]
        SLIGHT_RIGHT = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"SLIGHT_LEFT")]
        SLIGHT_LEFT = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"SHARP_LEFT")]
        SHARP_LEFT = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"SHARP_RIGHT")]
        SHARP_RIGHT = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties4
    {

        /// <summary>
        /// Indicates if there is wheelchair access available at this stop.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("WheelchairAccess")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public Properties4WheelchairAccess? WheelchairAccess { get; set; }

        /// <summary>
        /// Describes a list of downloadable files relevant to this location.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("downloads")]
        public System.Collections.Generic.ICollection<TripRequestResponseJourneyLegStopDownload> Downloads { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegStopType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 7,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegStopFootpathInfoPosition
    {

        [System.Runtime.Serialization.EnumMember(Value = @"BEFORE")]
        BEFORE = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"AFTER")]
        AFTER = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"IDEST")]
        IDEST = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegStopFootpathInfoFootpathElemLevel
    {

        [System.Runtime.Serialization.EnumMember(Value = @"DOWN")]
        DOWN = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"LEVEL")]
        LEVEL = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"UP")]
        UP = 2,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegStopFootpathInfoFootpathElemType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"ESCALATOR")]
        ESCALATOR = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"ELEVATOR")]
        ELEVATOR = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"STAIRS")]
        STAIRS = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"LEVEL")]
        LEVEL = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"RAMP")]
        RAMP = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Location
    {

        /// <summary>
        /// Contains exactly two values: the first value is the latitude, the second value is the longitude.
        /// <br/>Although multiple instructions may reference the same location, this coordinate is specific
        /// <br/>to this particular instruction.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("coord")]
        public System.Collections.Generic.ICollection<double> Coord { get; set; }

        /// <summary>
        /// This the unique ID for the stop in which this instruction occurs.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the type of location in which this instruction occurs.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
        public LocationType? Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum TripRequestResponseJourneyLegStopInfoPriority
    {

        [System.Runtime.Serialization.EnumMember(Value = @"veryLow")]
        VeryLow = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"low")]
        Low = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"normal")]
        Normal = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"high")]
        High = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"veryHigh")]
        VeryHigh = 4,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Destination2
    {

        /// <summary>
        /// Contains a unique identifier (if available) of the destination for this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// This is the name of the destination for this route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Operator
    {

        /// <summary>
        /// Contains a unique identifier for the given operator.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Contains the name of the operator of the route.
        /// <br/>
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Properties5
    {

        /// <summary>
        /// XXX
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("isTTB")]
        public bool? IsTTB { get; set; }

        /// <summary>
        /// This is an ID for this journey option.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("tripCode")]
        public int? TripCode { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Affected2
    {

        /// <summary>
        /// The specifies all of the lines that are listed as affected in the alert information.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("lines")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseAffectedLine> Lines { get; set; }

        /// <summary>
        /// The specifies all of the stops that are listed as affected in the alert information.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("stops")]
        public System.Collections.Generic.ICollection<AdditionalInfoResponseAffectedStop> Stops { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum DestinationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"gisPoint")]
        GisPoint = 7,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 8,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class Source
    {

        /// <summary>
        /// A unique identifier for the creator of this alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// The name of the creator of this alert.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// The type of system of the alert creator.
        /// </summary>
        [System.Text.Json.Serialization.JsonPropertyName("type")]
        public string Type { get; set; }

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties2GIS_DRAW_CLASS_TYPE
    {

        [System.Runtime.Serialization.EnumMember(Value = @"POINT")]
        POINT = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties2POI_DRAW_CLASS_TYPE
    {

        [System.Runtime.Serialization.EnumMember(Value = @"POINT")]
        POINT = 0,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum Properties4WheelchairAccess
    {

        [System.Runtime.Serialization.EnumMember(Value = @"true")]
        True = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"false")]
        False = 1,

    }

    [System.CodeDom.Compiler.GeneratedCode("NJsonSchema", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public enum LocationType
    {

        [System.Runtime.Serialization.EnumMember(Value = @"poi")]
        Poi = 0,

        [System.Runtime.Serialization.EnumMember(Value = @"singlehouse")]
        Singlehouse = 1,

        [System.Runtime.Serialization.EnumMember(Value = @"stop")]
        Stop = 2,

        [System.Runtime.Serialization.EnumMember(Value = @"platform")]
        Platform = 3,

        [System.Runtime.Serialization.EnumMember(Value = @"street")]
        Street = 4,

        [System.Runtime.Serialization.EnumMember(Value = @"locality")]
        Locality = 5,

        [System.Runtime.Serialization.EnumMember(Value = @"suburb")]
        Suburb = 6,

        [System.Runtime.Serialization.EnumMember(Value = @"unknown")]
        Unknown = 7,

    }



    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripPlannerException : System.Exception
    {
        public int StatusCode { get; private set; }

        public string Response { get; private set; }

        public System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> Headers { get; private set; }

        public TripPlannerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, System.Exception innerException)
            : base(message + "\n\nStatus: " + statusCode + "\nResponse: \n" + ((response == null) ? "(null)" : response.Substring(0, response.Length >= 512 ? 512 : response.Length)), innerException)
        {
            StatusCode = statusCode;
            Response = response;
            Headers = headers;
        }

        public override string ToString()
        {
            return string.Format("HTTP Response: \n\n{0}\n\n{1}", Response, base.ToString());
        }
    }

    [System.CodeDom.Compiler.GeneratedCode("NSwag", "14.5.0.0 (NJsonSchema v11.4.0.0 (Newtonsoft.Json v13.0.0.0))")]
    public partial class TripPlannerException<TResult> : TripPlannerException
    {
        public TResult Result { get; private set; }

        public TripPlannerException(string message, int statusCode, string response, System.Collections.Generic.IReadOnlyDictionary<string, System.Collections.Generic.IEnumerable<string>> headers, TResult result, System.Exception innerException)
            : base(message, statusCode, response, headers, innerException)
        {
            Result = result;
        }
    }

}

#pragma warning restore  108
#pragma warning restore  114
#pragma warning restore  472
#pragma warning restore  612
#pragma warning restore  649
#pragma warning restore 1573
#pragma warning restore 1591
#pragma warning restore 8073
#pragma warning restore 3016
#pragma warning restore 8600
#pragma warning restore 8602
#pragma warning restore 8603
#pragma warning restore 8604
#pragma warning restore 8625
#pragma warning restore 8765